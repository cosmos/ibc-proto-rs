// This file is @generated by prost-build.
/// WARNING: This message is deprecated in favor of `MsgCreateConsumer`.
/// ConsumerAdditionProposal is a governance proposal on the provider chain to
/// spawn a new consumer chain. If it passes, then all validators on the provider
/// chain are expected to validate the consumer chain at spawn time or get
/// slashed. It is recommended that spawn time occurs after the proposal end
/// time.
/// Use MsgConsumerAddition to submit this proposal type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAdditionProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the proposed chain-id of the new consumer chain, must be different from all
    /// other consumer chain ids of the executing provider chain.
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// the proposed initial height of new consumer chain.
    /// For a completely new chain, this will be {0,1}. However, it may be
    /// different if this is a chain that is converting to a consumer chain.
    #[prost(message, optional, tag = "4")]
    pub initial_height: ::core::option::Option<
        super::super::super::super::ibc::core::client::v1::Height,
    >,
    /// The hash of the consumer chain genesis state without the consumer CCV
    /// module genesis params. It is used for off-chain confirmation of
    /// genesis.json validity by validators and other parties.
    #[prost(bytes = "vec", tag = "5")]
    pub genesis_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the consumer chain binary that should be run by validators on
    /// chain initialization. It is used for off-chain confirmation of binary
    /// validity by validators and other parties.
    #[prost(bytes = "vec", tag = "6")]
    pub binary_hash: ::prost::alloc::vec::Vec<u8>,
    /// spawn time is the time on the provider chain at which the consumer chain
    /// genesis is finalized and all validators will be responsible for starting
    /// their consumer chain validator node.
    #[prost(message, optional, tag = "7")]
    pub spawn_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// Unbonding period for the consumer,
    /// which should be smaller than that of the provider in general.
    #[prost(message, optional, tag = "8")]
    pub unbonding_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent CCV related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "9")]
    pub ccv_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent transfer related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "10")]
    pub transfer_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// The fraction of tokens allocated to the consumer redistribution address
    /// during distribution events. The fraction is a string representing a
    /// decimal number. For example "0.75" would represent 75%.
    #[prost(string, tag = "11")]
    pub consumer_redistribution_fraction: ::prost::alloc::string::String,
    /// BlocksPerDistributionTransmission is the number of blocks between
    /// ibc-token-transfers from the consumer chain to the provider chain. On
    /// sending transmission event, `consumer_redistribution_fraction` of the
    /// accumulated tokens are sent to the consumer redistribution address.
    #[prost(int64, tag = "12")]
    pub blocks_per_distribution_transmission: i64,
    /// The number of historical info entries to persist in store.
    /// This param is a part of the cosmos sdk staking module. In the case of
    /// a ccv enabled consumer chain, the ccv module acts as the staking module.
    #[prost(int64, tag = "13")]
    pub historical_entries: i64,
    /// The ID of a token transfer channel used for the Reward Distribution
    /// sub-protocol. If DistributionTransmissionChannel == "", a new transfer
    /// channel is created on top of the same connection as the CCV channel.
    /// Note that transfer_channel_id is the ID of the channel end on the consumer
    /// chain. it is most relevant for chains performing a sovereign to consumer
    /// changeover in order to maintain the existing ibc transfer channel
    #[prost(string, tag = "14")]
    pub distribution_transmission_channel: ::prost::alloc::string::String,
    /// Corresponds to the percentage of validators that have to validate the chain under the Top N case.
    /// For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
    /// have to validate the proposed consumer chain. top_N can either be 0 or any value in \[50, 100\].
    /// A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ \[50, 100\] as a Top N chain.
    #[prost(uint32, tag = "15")]
    pub top_n: u32,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
    /// `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
    /// consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
    /// 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
    /// to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
    #[prost(uint32, tag = "16")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "17")]
    pub validator_set_cap: u32,
    /// Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
    /// the consumer chain.
    #[prost(string, repeated, tag = "18")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
    #[prost(string, repeated, tag = "19")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "20")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "21")]
    pub allow_inactive_vals: bool,
}
impl ::prost::Name for ConsumerAdditionProposal {
    const NAME: &'static str = "ConsumerAdditionProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAdditionProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAdditionProposal".into()
    }
}
/// WARNING: This message is deprecated in favor of `MsgRemoveConsumer`.
/// ConsumerRemovalProposal is a governance proposal on the provider chain to
/// remove (and stop) a consumer chain. If it passes, all the consumer chain's
/// state is removed from the provider chain. The outstanding unbonding operation
/// funds are released.
/// Use MsgConsumerRemoval to submit this proposal type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerRemovalProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the chain-id of the consumer chain to be stopped
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// the time on the provider chain at which all validators are responsible to
    /// stop their consumer chain validator node
    #[prost(message, optional, tag = "4")]
    pub stop_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
impl ::prost::Name for ConsumerRemovalProposal {
    const NAME: &'static str = "ConsumerRemovalProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerRemovalProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerRemovalProposal".into()
    }
}
/// WARNING: This message is deprecated in favor of `MsgUpdateConsumer`.
/// ConsumerModificationProposal is a governance proposal on the provider chain to modify parameters of a running
/// consumer chain. If it passes, the consumer chain's state is updated to take into account the newest params.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerModificationProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the chain-id of the consumer chain to be modified
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// Corresponds to the percentage of validators that have to validate the chain under the Top N case.
    /// For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
    /// have to validate the proposed consumer chain. top_N can either be 0 or any value in \[50, 100\].
    /// A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ \[50, 100\] as a Top N chain.
    #[prost(uint32, tag = "4")]
    pub top_n: u32,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
    /// `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
    /// consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
    /// 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
    /// to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
    #[prost(uint32, tag = "5")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "6")]
    pub validator_set_cap: u32,
    /// Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
    /// the consumer chain.
    #[prost(string, repeated, tag = "7")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
    #[prost(string, repeated, tag = "8")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "9")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "10")]
    pub allow_inactive_vals: bool,
}
impl ::prost::Name for ConsumerModificationProposal {
    const NAME: &'static str = "ConsumerModificationProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerModificationProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerModificationProposal".into()
    }
}
/// EquivocationProposal is a governance proposal on the provider chain to
/// punish a validator for equivocation on a consumer chain.
///
/// This type is only used internally to the consumer CCV module.
/// WARNING: This message is deprecated now that equivocations can be submitted
/// and verified automatically on the provider. (see SubmitConsumerDoubleVoting in proto/interchain-security/ccv/provider/v1/tx.proto).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquivocationProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the list of equivocations that will be processed
    #[prost(message, repeated, tag = "3")]
    pub equivocations: ::prost::alloc::vec::Vec<
        super::super::super::super::cosmos::evidence::v1beta1::Equivocation,
    >,
}
impl ::prost::Name for EquivocationProposal {
    const NAME: &'static str = "EquivocationProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.EquivocationProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.EquivocationProposal".into()
    }
}
/// ChangeRewardDenomsProposal is a governance proposal on the provider chain to
/// mutate the set of denoms accepted by the provider as rewards.
/// Use MsgChangeRewardDenoms to submit this proposal type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeRewardDenomsProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the list of consumer reward denoms to add
    #[prost(string, repeated, tag = "3")]
    pub denoms_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of consumer reward denoms to remove
    #[prost(string, repeated, tag = "4")]
    pub denoms_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ChangeRewardDenomsProposal {
    const NAME: &'static str = "ChangeRewardDenomsProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ChangeRewardDenomsProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ChangeRewardDenomsProposal".into()
    }
}
/// A persisted queue entry indicating that a slash packet data instance needs to
/// be handled. This type belongs in the "global" queue, to coordinate slash
/// packet handling times between consumers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSlashEntry {
    /// Block time that slash packet was received by provider chain.
    /// This field is used for store key iteration ordering.
    #[prost(message, optional, tag = "1")]
    pub recv_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// The consumer that sent a slash packet.
    #[prost(string, tag = "2")]
    pub consumer_chain_id: ::prost::alloc::string::String,
    /// The IBC sequence number of the recv packet.
    /// This field is used in the store key to ensure uniqueness.
    #[prost(uint64, tag = "3")]
    pub ibc_seq_num: u64,
    /// The provider's consensus address of the validator being slashed.
    /// This field is used to obtain validator power in HandleThrottleQueues.
    ///
    /// This field is not used in the store key, but is persisted in value bytes,
    /// see QueueGlobalSlashEntry.
    #[prost(bytes = "vec", tag = "4")]
    pub provider_val_cons_addr: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for GlobalSlashEntry {
    const NAME: &'static str = "GlobalSlashEntry";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.GlobalSlashEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.GlobalSlashEntry".into()
    }
}
/// Params defines the parameters for CCV Provider module
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    #[prost(message, optional, tag = "1")]
    pub template_client: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::ClientState,
    >,
    /// TrustingPeriodFraction is used to compute the consumer and provider IBC
    /// client's TrustingPeriod from the chain defined UnbondingPeriod
    #[prost(string, tag = "2")]
    pub trusting_period_fraction: ::prost::alloc::string::String,
    /// Sent IBC packets will timeout after this duration
    #[prost(message, optional, tag = "3")]
    pub ccv_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// The period for which the slash meter is replenished
    #[prost(message, optional, tag = "6")]
    pub slash_meter_replenish_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// The fraction of total voting power that is replenished to the slash meter
    /// every replenish period. This param also serves as a maximum fraction of
    /// total voting power that the slash meter can hold.
    #[prost(string, tag = "7")]
    pub slash_meter_replenish_fraction: ::prost::alloc::string::String,
    /// The fee required to be paid to add a reward denom
    #[prost(message, optional, tag = "9")]
    pub consumer_reward_denom_registration_fee: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The number of blocks that comprise an epoch.
    #[prost(int64, tag = "10")]
    pub blocks_per_epoch: i64,
    /// The number of epochs a validator has to validate a consumer chain in order to start receiving rewards from that chain.
    #[prost(int64, tag = "11")]
    pub number_of_epochs_to_start_receiving_rewards: i64,
    /// The maximal number of validators that will be passed
    /// to the consensus engine on the provider.
    #[prost(int64, tag = "12")]
    pub max_provider_consensus_validators: i64,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.Params".into()
    }
}
/// SlashAcks contains cons addresses of consumer chain validators
/// successfully slashed on the provider chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlashAcks {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for SlashAcks {
    const NAME: &'static str = "SlashAcks";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.SlashAcks".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.SlashAcks".into()
    }
}
/// ConsumerAdditionProposals holds pending governance proposals on the provider
/// chain to spawn a new chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAdditionProposals {
    /// proposals waiting for spawn_time to pass
    #[prost(message, repeated, tag = "1")]
    pub pending: ::prost::alloc::vec::Vec<ConsumerAdditionProposal>,
}
impl ::prost::Name for ConsumerAdditionProposals {
    const NAME: &'static str = "ConsumerAdditionProposals";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAdditionProposals".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAdditionProposals".into()
    }
}
/// ConsumerRemovalProposals holds pending governance proposals on the provider
/// chain to remove (and stop) a consumer chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerRemovalProposals {
    /// proposals waiting for stop_time to pass
    #[prost(message, repeated, tag = "1")]
    pub pending: ::prost::alloc::vec::Vec<ConsumerRemovalProposal>,
}
impl ::prost::Name for ConsumerRemovalProposals {
    const NAME: &'static str = "ConsumerRemovalProposals";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerRemovalProposals".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerRemovalProposals".into()
    }
}
/// AddressList contains a list of consensus addresses
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressList {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for AddressList {
    const NAME: &'static str = "AddressList";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.AddressList".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.AddressList".into()
    }
}
/// WARNING: This message is deprecated and is not used.
/// ChannelToChain is used to map a CCV channel ID to the consumer chainID
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelToChain {
    #[prost(string, tag = "1")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
}
impl ::prost::Name for ChannelToChain {
    const NAME: &'static str = "ChannelToChain";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ChannelToChain".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ChannelToChain".into()
    }
}
/// ValidatorSetChangePackets is a pb list of ccv.ValidatorSetChangePacketData.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSetChangePackets {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<super::super::v1::ValidatorSetChangePacketData>,
}
impl ::prost::Name for ValidatorSetChangePackets {
    const NAME: &'static str = "ValidatorSetChangePackets";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorSetChangePackets".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorSetChangePackets".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyAssignmentReplacement {
    #[prost(bytes = "vec", tag = "1")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub prev_c_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
    #[prost(int64, tag = "3")]
    pub power: i64,
}
impl ::prost::Name for KeyAssignmentReplacement {
    const NAME: &'static str = "KeyAssignmentReplacement";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.KeyAssignmentReplacement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.KeyAssignmentReplacement".into()
    }
}
/// Used to serialize the ValidatorConsumerPubKey index from key assignment
/// ValidatorConsumerPubKey: (chainID, providerAddr consAddr) -> consumerKey
/// tmprotocrypto.PublicKey
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorConsumerPubKey {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub consumer_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
}
impl ::prost::Name for ValidatorConsumerPubKey {
    const NAME: &'static str = "ValidatorConsumerPubKey";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorConsumerPubKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorConsumerPubKey".into()
    }
}
/// Used to serialize the ValidatorConsumerAddr index from key assignment
/// ValidatorByConsumerAddr: (chainID, consumerAddr consAddr) -> providerAddr
/// consAddr
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorByConsumerAddr {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub consumer_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for ValidatorByConsumerAddr {
    const NAME: &'static str = "ValidatorByConsumerAddr";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorByConsumerAddr".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorByConsumerAddr".into()
    }
}
/// Used to serialize the ConsumerAddrsToPruneV2 index from key assignment
/// ConsumerAddrsToPruneV2: (chainID, pruneTs time.Time) -> consumerAddrs AddressList
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAddrsToPruneV2 {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub prune_ts: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    #[prost(message, optional, tag = "3")]
    pub consumer_addrs: ::core::option::Option<AddressList>,
}
impl ::prost::Name for ConsumerAddrsToPruneV2 {
    const NAME: &'static str = "ConsumerAddrsToPruneV2";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAddrsToPruneV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAddrsToPruneV2".into()
    }
}
/// ConsensusValidator is used to express a validator that
/// should be validating on a chain.
/// It contains relevant info for
/// a validator that is expected to validate on
/// either the provider or a consumer chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusValidator {
    /// validator's consensus address on the provider chain
    #[prost(bytes = "vec", tag = "1")]
    pub provider_cons_addr: ::prost::alloc::vec::Vec<u8>,
    /// voting power the validator has during this epoch
    #[prost(int64, tag = "2")]
    pub power: i64,
    /// public key the validator uses on the consumer chain during this epoch
    #[prost(message, optional, tag = "3")]
    pub public_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
    /// height the validator had when it FIRST became a consumer validator
    /// If a validator becomes a consumer validator at height `H` and is continuously a consumer validator for all the upcoming
    /// epochs, then the height of the validator SHOULD remain `H`. This height only resets to a different height if a validator
    /// stops being a consumer validator during an epoch and later becomes again a consumer validator.
    #[prost(int64, tag = "4")]
    pub join_height: i64,
}
impl ::prost::Name for ConsensusValidator {
    const NAME: &'static str = "ConsensusValidator";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsensusValidator".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsensusValidator".into()
    }
}
/// ConsumerRewardsAllocation stores the rewards allocated by a consumer chain
/// to the consumer rewards pool. It is used to allocate the tokens to the consumer
/// opted-in validators and the community pool during BeginBlock.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerRewardsAllocation {
    #[prost(message, repeated, tag = "1")]
    pub rewards: ::prost::alloc::vec::Vec<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
}
impl ::prost::Name for ConsumerRewardsAllocation {
    const NAME: &'static str = "ConsumerRewardsAllocation";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerRewardsAllocation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerRewardsAllocation".into()
    }
}
/// ConsumerMetadata contains general information about the registered chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerMetadata {
    /// the name of the chain
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the description of the chain
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the metadata (e.g., GitHub repository URL) of the chain
    #[prost(string, tag = "3")]
    pub metadata: ::prost::alloc::string::String,
}
impl ::prost::Name for ConsumerMetadata {
    const NAME: &'static str = "ConsumerMetadata";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerMetadata".into()
    }
}
/// ConsumerInitializationParameters are the parameters needed to launch a chain
///
/// ---------- ---------- ----------
/// Following fields are used when the consumer chain launches and are not needed by the provider afterwards.
/// ---------- ---------- ----------
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerInitializationParameters {
    /// the proposed initial height of new consumer chain.
    /// For a completely new chain, this will be {0,1}. However, it may be
    /// different if this is a chain that is converting to a consumer chain.
    #[prost(message, optional, tag = "1")]
    pub initial_height: ::core::option::Option<
        super::super::super::super::ibc::core::client::v1::Height,
    >,
    /// The hash of the consumer chain genesis state without the consumer CCV
    /// module genesis params. It is used for off-chain confirmation of
    /// genesis.json validity by validators and other parties.
    #[prost(bytes = "vec", tag = "2")]
    pub genesis_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the consumer chain binary that should be run by validators on
    /// chain initialization. It is used for off-chain confirmation of binary
    /// validity by validators and other parties.
    #[prost(bytes = "vec", tag = "3")]
    pub binary_hash: ::prost::alloc::vec::Vec<u8>,
    /// spawn time is the time on the provider chain at which the consumer chain
    /// genesis is finalized and all validators will be responsible for starting
    /// their consumer chain validator node.
    #[prost(message, optional, tag = "4")]
    pub spawn_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// Unbonding period for the consumer,
    /// which should be smaller than that of the provider in general.
    #[prost(message, optional, tag = "5")]
    pub unbonding_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent CCV related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "6")]
    pub ccv_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent transfer related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "7")]
    pub transfer_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// The fraction of tokens allocated to the consumer redistribution address
    /// during distribution events. The fraction is a string representing a
    /// decimal number. For example "0.75" would represent 75%.
    #[prost(string, tag = "8")]
    pub consumer_redistribution_fraction: ::prost::alloc::string::String,
    /// BlocksPerDistributionTransmission is the number of blocks between
    /// ibc-token-transfers from the consumer chain to the provider chain. On
    /// sending transmission event, `consumer_redistribution_fraction` of the
    /// accumulated tokens are sent to the consumer redistribution address.
    #[prost(int64, tag = "9")]
    pub blocks_per_distribution_transmission: i64,
    /// The number of historical info entries to persist in store.
    /// This param is a part of the cosmos sdk staking module. In the case of
    /// a ccv enabled consumer chain, the ccv module acts as the staking module.
    #[prost(int64, tag = "10")]
    pub historical_entries: i64,
    /// The ID of a token transfer channel used for the Reward Distribution
    /// sub-protocol. If DistributionTransmissionChannel == "", a new transfer
    /// channel is created on top of the same connection as the CCV channel.
    /// Note that transfer_channel_id is the ID of the channel end on the consumer
    /// chain. it is most relevant for chains performing a sovereign to consumer
    /// changeover in order to maintain the existing ibc transfer channel
    #[prost(string, tag = "11")]
    pub distribution_transmission_channel: ::prost::alloc::string::String,
}
impl ::prost::Name for ConsumerInitializationParameters {
    const NAME: &'static str = "ConsumerInitializationParameters";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerInitializationParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerInitializationParameters".into()
    }
}
/// PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowerShapingParameters {
    /// Corresponds to the percentage of validators that have to validate the chain under the Top N case.
    /// For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
    /// have to validate the proposed consumer chain. top_N can either be 0 or any value in \[50, 100\].
    /// A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ \[50, 100\] as a Top N chain.
    #[prost(uint32, tag = "1")]
    pub top_n: u32,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
    /// `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
    /// consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
    /// 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
    /// to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
    #[prost(uint32, tag = "2")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "3")]
    pub validator_set_cap: u32,
    /// corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain
    #[prost(string, repeated, tag = "4")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain
    #[prost(string, repeated, tag = "5")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "6")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "7")]
    pub allow_inactive_vals: bool,
}
impl ::prost::Name for PowerShapingParameters {
    const NAME: &'static str = "PowerShapingParameters";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.PowerShapingParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.PowerShapingParameters".into()
    }
}
/// ConsumerIds contains consumer ids of chains
/// Used so we can easily (de)serialize slices of strings
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerIds {
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ConsumerIds {
    const NAME: &'static str = "ConsumerIds";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerIds".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerIds".into()
    }
}
/// ConsumerPhase indicates the phases of a consumer chain according to ADR 019
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsumerPhase {
    /// UNSPECIFIED defines an empty phase.
    Unspecified = 0,
    /// REGISTERED defines the phase in which a consumer chain has been assigned a unique consumer id.
    /// A chain in this phase cannot yet launch.
    Registered = 1,
    /// INITIALIZED defines the phase in which a consumer chain has set all the needed parameters to launch but
    /// has not yet launched (e.g., because the `spawnTime` of the consumer chain has not yet been reached).
    Initialized = 2,
    /// LAUNCHED defines the phase in which a consumer chain is running and consuming a subset of the validator
    /// set of the provider.
    Launched = 3,
    /// STOPPED defines the phase in which a previously-launched chain has stopped.
    Stopped = 4,
    /// DELETED defines the phase in which the state of a stopped chain has been deleted.
    Deleted = 5,
}
impl ConsumerPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConsumerPhase::Unspecified => "CONSUMER_PHASE_UNSPECIFIED",
            ConsumerPhase::Registered => "CONSUMER_PHASE_REGISTERED",
            ConsumerPhase::Initialized => "CONSUMER_PHASE_INITIALIZED",
            ConsumerPhase::Launched => "CONSUMER_PHASE_LAUNCHED",
            ConsumerPhase::Stopped => "CONSUMER_PHASE_STOPPED",
            ConsumerPhase::Deleted => "CONSUMER_PHASE_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSUMER_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSUMER_PHASE_REGISTERED" => Some(Self::Registered),
            "CONSUMER_PHASE_INITIALIZED" => Some(Self::Initialized),
            "CONSUMER_PHASE_LAUNCHED" => Some(Self::Launched),
            "CONSUMER_PHASE_STOPPED" => Some(Self::Stopped),
            "CONSUMER_PHASE_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAssignConsumerKey {
    /// \[DEPRECATED\] use `consumer_id` instead
    #[deprecated]
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// The validator address on the provider
    #[prost(string, tag = "2")]
    pub provider_addr: ::prost::alloc::string::String,
    /// The consensus public key to use on the consumer.
    /// in json string format corresponding to proto-any, ex:
    /// `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`
    #[prost(string, tag = "3")]
    pub consumer_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub signer: ::prost::alloc::string::String,
    /// the consumer id of the consumer chain to assign a consensus public key to
    #[prost(string, tag = "5")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAssignConsumerKey {
    const NAME: &'static str = "MsgAssignConsumerKey";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgAssignConsumerKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgAssignConsumerKey".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAssignConsumerKeyResponse {}
impl ::prost::Name for MsgAssignConsumerKeyResponse {
    const NAME: &'static str = "MsgAssignConsumerKeyResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgAssignConsumerKeyResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgAssignConsumerKeyResponse".into()
    }
}
/// MsgSubmitConsumerMisbehaviour defines a message that reports a light client attack,
/// also known as a misbehaviour, observed on a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerMisbehaviour {
    #[prost(string, tag = "1")]
    pub submitter: ::prost::alloc::string::String,
    /// The Misbehaviour of the consumer chain wrapping
    /// two conflicting IBC headers
    #[prost(message, optional, tag = "2")]
    pub misbehaviour: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::Misbehaviour,
    >,
    /// the consumer id of the consumer chain where the misbehaviour occurred
    #[prost(string, tag = "3")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSubmitConsumerMisbehaviour {
    const NAME: &'static str = "MsgSubmitConsumerMisbehaviour";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviour".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviour".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerMisbehaviourResponse {}
impl ::prost::Name for MsgSubmitConsumerMisbehaviourResponse {
    const NAME: &'static str = "MsgSubmitConsumerMisbehaviourResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviourResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviourResponse"
            .into()
    }
}
/// MsgSubmitConsumerDoubleVoting defines a message that reports
/// a double signing infraction observed on a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerDoubleVoting {
    #[prost(string, tag = "1")]
    pub submitter: ::prost::alloc::string::String,
    /// The equivocation of the consumer chain wrapping
    /// an evidence of a validator that signed two conflicting votes
    #[prost(message, optional, tag = "2")]
    pub duplicate_vote_evidence: ::core::option::Option<
        ::tendermint_proto::types::DuplicateVoteEvidence,
    >,
    /// The light client header of the infraction block
    #[prost(message, optional, tag = "3")]
    pub infraction_block_header: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::Header,
    >,
    /// the consumer id of the consumer chain where the double-voting took place
    #[prost(string, tag = "4")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSubmitConsumerDoubleVoting {
    const NAME: &'static str = "MsgSubmitConsumerDoubleVoting";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVoting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVoting".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerDoubleVotingResponse {}
impl ::prost::Name for MsgSubmitConsumerDoubleVotingResponse {
    const NAME: &'static str = "MsgSubmitConsumerDoubleVotingResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVotingResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVotingResponse"
            .into()
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// params defines the x/provider parameters to update.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgUpdateParams".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgUpdateParamsResponse".into()
    }
}
/// \[DEPRECATED\] Use `MsgCreateConsumer` instead
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgConsumerAddition {
    /// the proposed chain-id of the new consumer chain, must be different from all
    /// other consumer chain ids of the executing provider chain.
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// the proposed initial height of new consumer chain.
    /// For a completely new chain, this will be {0,1}. However, it may be
    /// different if this is a chain that is converting to a consumer chain.
    #[prost(message, optional, tag = "2")]
    pub initial_height: ::core::option::Option<
        super::super::super::super::ibc::core::client::v1::Height,
    >,
    /// The hash of the consumer chain genesis state without the consumer CCV
    /// module genesis params. It is used for off-chain confirmation of
    /// genesis.json validity by validators and other parties.
    #[prost(bytes = "vec", tag = "3")]
    pub genesis_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the consumer chain binary that should be run by validators on
    /// chain initialization. It is used for off-chain confirmation of binary
    /// validity by validators and other parties.
    #[prost(bytes = "vec", tag = "4")]
    pub binary_hash: ::prost::alloc::vec::Vec<u8>,
    /// spawn time is the time on the provider chain at which the consumer chain
    /// genesis is finalized and all validators will be responsible for starting
    /// their consumer chain validator node.
    #[prost(message, optional, tag = "5")]
    pub spawn_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// Unbonding period for the consumer,
    /// which should be smaller than that of the provider in general.
    #[prost(message, optional, tag = "6")]
    pub unbonding_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent CCV related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "7")]
    pub ccv_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// Sent transfer related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "8")]
    pub transfer_timeout_period: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Duration,
    >,
    /// The fraction of tokens allocated to the consumer redistribution address
    /// during distribution events. The fraction is a string representing a
    /// decimal number. For example "0.75" would represent 75%.
    #[prost(string, tag = "9")]
    pub consumer_redistribution_fraction: ::prost::alloc::string::String,
    /// BlocksPerDistributionTransmission is the number of blocks between
    /// ibc-token-transfers from the consumer chain to the provider chain. On
    /// sending transmission event, `consumer_redistribution_fraction` of the
    /// accumulated tokens are sent to the consumer redistribution address.
    #[prost(int64, tag = "10")]
    pub blocks_per_distribution_transmission: i64,
    /// The number of historical info entries to persist in store.
    /// This param is a part of the cosmos sdk staking module. In the case of
    /// a ccv enabled consumer chain, the ccv module acts as the staking module.
    #[prost(int64, tag = "11")]
    pub historical_entries: i64,
    /// The ID of a token transfer channel used for the Reward Distribution
    /// sub-protocol. If DistributionTransmissionChannel == "", a new transfer
    /// channel is created on top of the same connection as the CCV channel.
    /// Note that transfer_channel_id is the ID of the channel end on the consumer
    /// chain. it is most relevant for chains performing a sovereign to consumer
    /// changeover in order to maintain the existing ibc transfer channel
    #[prost(string, tag = "12")]
    pub distribution_transmission_channel: ::prost::alloc::string::String,
    /// Corresponds to the percentage of validators that have to validate the chain under the Top N case.
    /// For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
    /// have to validate the proposed consumer chain. top_N can either be 0 or any value in \[50, 100\].
    /// A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ \[50, 100\] as a Top N chain.
    #[prost(uint32, tag = "13")]
    pub top_n: u32,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
    /// `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
    /// consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
    /// 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
    /// to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
    #[prost(uint32, tag = "14")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "15")]
    pub validator_set_cap: u32,
    /// Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
    /// the consumer chain.
    #[prost(string, repeated, tag = "16")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
    #[prost(string, repeated, tag = "17")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// signer address
    #[prost(string, tag = "18")]
    pub authority: ::prost::alloc::string::String,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "19")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "20")]
    pub allow_inactive_vals: bool,
}
impl ::prost::Name for MsgConsumerAddition {
    const NAME: &'static str = "MsgConsumerAddition";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgConsumerAddition".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgConsumerAddition".into()
    }
}
/// \[DEPRECATED\] Use `MsgRemoveConsumer` instead
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgConsumerRemoval {
    /// the chain-id of the consumer chain to be stopped
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// the time on the provider chain at which all validators are responsible to
    /// stop their consumer chain validator node
    #[prost(message, optional, tag = "2")]
    pub stop_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// signer address
    #[prost(string, tag = "3")]
    pub authority: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgConsumerRemoval {
    const NAME: &'static str = "MsgConsumerRemoval";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgConsumerRemoval".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgConsumerRemoval".into()
    }
}
/// MsgRemoveConsumer defines the message used to remove (and stop) a consumer chain.
/// If it passes, all the consumer chain's state is eventually removed from the provider chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveConsumer {
    /// the consumer id of the consumer chain to be stopped
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
    /// the address of the owner of the consumer chain to be stopped
    #[prost(string, tag = "2")]
    pub owner: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRemoveConsumer {
    const NAME: &'static str = "MsgRemoveConsumer";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgRemoveConsumer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgRemoveConsumer".into()
    }
}
/// MsgRemoveConsumerResponse defines response type for MsgRemoveConsumer messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveConsumerResponse {}
impl ::prost::Name for MsgRemoveConsumerResponse {
    const NAME: &'static str = "MsgRemoveConsumerResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgRemoveConsumerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgRemoveConsumerResponse".into()
    }
}
/// ChangeRewardDenomsProposal is a governance proposal on the provider chain to
/// mutate the set of denoms accepted by the provider as rewards.
///
/// Note: this replaces ChangeRewardDenomsProposal which is deprecated and will be removed soon
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgChangeRewardDenoms {
    /// the list of consumer reward denoms to add
    #[prost(string, repeated, tag = "1")]
    pub denoms_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of consumer reward denoms to remove
    #[prost(string, repeated, tag = "2")]
    pub denoms_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// authority is the address of the governance account
    #[prost(string, tag = "3")]
    pub authority: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgChangeRewardDenoms {
    const NAME: &'static str = "MsgChangeRewardDenoms";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgChangeRewardDenoms".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgChangeRewardDenoms".into()
    }
}
/// MsgChangeRewardDenomsResponse defines response type for MsgChangeRewardDenoms messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgChangeRewardDenomsResponse {}
impl ::prost::Name for MsgChangeRewardDenomsResponse {
    const NAME: &'static str = "MsgChangeRewardDenomsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgChangeRewardDenomsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgChangeRewardDenomsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgOptIn {
    /// \[DEPRECATED\] use `consumer_id` instead
    #[deprecated]
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// the validator address on the provider
    #[prost(string, tag = "2")]
    pub provider_addr: ::prost::alloc::string::String,
    /// (optional) The consensus public key to use on the consumer in json string format corresponding to proto-any,
    /// for example `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`.
    /// This field is optional and can remain empty (i.e., `consumer_key = ""`). A validator can always change the
    /// consumer public key at a later stage by issuing a `MsgAssignConsumerKey` message.
    #[prost(string, tag = "3")]
    pub consumer_key: ::prost::alloc::string::String,
    /// submitter address
    #[prost(string, tag = "4")]
    pub signer: ::prost::alloc::string::String,
    /// the consumer id of the consumer chain to opt in to
    #[prost(string, tag = "5")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgOptIn {
    const NAME: &'static str = "MsgOptIn";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgOptIn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgOptIn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgOptInResponse {}
impl ::prost::Name for MsgOptInResponse {
    const NAME: &'static str = "MsgOptInResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgOptInResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgOptInResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgOptOut {
    /// \[DEPRECATED\] use `consumer_id` instead
    #[deprecated]
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// the validator address on the provider
    #[prost(string, tag = "2")]
    pub provider_addr: ::prost::alloc::string::String,
    /// submitter address
    #[prost(string, tag = "3")]
    pub signer: ::prost::alloc::string::String,
    /// the consumer id of the consumer chain to opt out from
    #[prost(string, tag = "4")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgOptOut {
    const NAME: &'static str = "MsgOptOut";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgOptOut".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgOptOut".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgOptOutResponse {}
impl ::prost::Name for MsgOptOutResponse {
    const NAME: &'static str = "MsgOptOutResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgOptOutResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgOptOutResponse".into()
    }
}
/// MsgSetConsumerCommissionRate allows validators to set
/// a per-consumer chain commission rate
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetConsumerCommissionRate {
    /// The validator address on the provider
    #[prost(string, tag = "1")]
    pub provider_addr: ::prost::alloc::string::String,
    /// \[DEPRECATED\] use `consumer_id` instead
    #[deprecated]
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    /// The rate to charge delegators on the consumer chain, as a fraction
    /// TODO: migrate rate from sdk.Dec to math.LegacyDec
    #[prost(string, tag = "3")]
    pub rate: ::prost::alloc::string::String,
    /// submitter address
    #[prost(string, tag = "4")]
    pub signer: ::prost::alloc::string::String,
    /// the consumer id of the consumer chain to set the commission rate
    #[prost(string, tag = "5")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSetConsumerCommissionRate {
    const NAME: &'static str = "MsgSetConsumerCommissionRate";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSetConsumerCommissionRate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSetConsumerCommissionRate".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetConsumerCommissionRateResponse {}
impl ::prost::Name for MsgSetConsumerCommissionRateResponse {
    const NAME: &'static str = "MsgSetConsumerCommissionRateResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSetConsumerCommissionRateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSetConsumerCommissionRateResponse"
            .into()
    }
}
/// \[DEPRECATED\] Use `MsgUpdateConsumer` instead
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgConsumerModification {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the chain-id of the consumer chain to be modified
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// Corresponds to the percentage of validators that have to validate the chain under the Top N case.
    /// For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
    /// have to validate the proposed consumer chain. top_N can either be 0 or any value in \[50, 100\].
    /// A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ \[50, 100\] as a Top N chain.
    #[prost(uint32, tag = "4")]
    pub top_n: u32,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
    /// `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
    /// consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
    /// 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
    /// to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
    #[prost(uint32, tag = "5")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "6")]
    pub validator_set_cap: u32,
    /// Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
    /// the consumer chain.
    #[prost(string, repeated, tag = "7")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
    #[prost(string, repeated, tag = "8")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// signer address
    #[prost(string, tag = "9")]
    pub authority: ::prost::alloc::string::String,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "10")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "11")]
    pub allow_inactive_vals: bool,
}
impl ::prost::Name for MsgConsumerModification {
    const NAME: &'static str = "MsgConsumerModification";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgConsumerModification".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgConsumerModification".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgConsumerModificationResponse {}
impl ::prost::Name for MsgConsumerModificationResponse {
    const NAME: &'static str = "MsgConsumerModificationResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgConsumerModificationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgConsumerModificationResponse".into()
    }
}
/// MsgCreateConsumer defines the message that creates a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateConsumer {
    /// Submitter address. If the message is successfully handled, the ownership of
    /// the consumer chain will given to this address.
    #[prost(string, tag = "1")]
    pub submitter: ::prost::alloc::string::String,
    /// the chain id of the new consumer chain
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ConsumerMetadata>,
    #[prost(message, optional, tag = "4")]
    pub initialization_parameters: ::core::option::Option<
        ConsumerInitializationParameters,
    >,
    #[prost(message, optional, tag = "5")]
    pub power_shaping_parameters: ::core::option::Option<PowerShapingParameters>,
}
impl ::prost::Name for MsgCreateConsumer {
    const NAME: &'static str = "MsgCreateConsumer";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgCreateConsumer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgCreateConsumer".into()
    }
}
/// MsgCreateConsumerResponse defines response type for MsgCreateConsumer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateConsumerResponse {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgCreateConsumerResponse {
    const NAME: &'static str = "MsgCreateConsumerResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgCreateConsumerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgCreateConsumerResponse".into()
    }
}
/// MsgUpdateConsumer defines the message used to modify a consumer chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateConsumer {
    /// the address of the owner of the consumer chain to be updated
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// the consumer id of the consumer chain to be updated
    #[prost(string, tag = "2")]
    pub consumer_id: ::prost::alloc::string::String,
    /// the new owner of the consumer when updated
    #[prost(string, tag = "3")]
    pub new_owner_address: ::prost::alloc::string::String,
    /// the metadata of the consumer when updated
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ConsumerMetadata>,
    /// initialization parameters can only be updated before a chain has launched
    #[prost(message, optional, tag = "5")]
    pub initialization_parameters: ::core::option::Option<
        ConsumerInitializationParameters,
    >,
    /// the power-shaping parameters of the consumer when updated
    #[prost(message, optional, tag = "6")]
    pub power_shaping_parameters: ::core::option::Option<PowerShapingParameters>,
}
impl ::prost::Name for MsgUpdateConsumer {
    const NAME: &'static str = "MsgUpdateConsumer";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgUpdateConsumer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgUpdateConsumer".into()
    }
}
/// MsgUpdateConsumerResponse defines response type for MsgUpdateConsumer messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateConsumerResponse {}
impl ::prost::Name for MsgUpdateConsumerResponse {
    const NAME: &'static str = "MsgUpdateConsumerResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgUpdateConsumerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgUpdateConsumerResponse".into()
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod msg_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn assign_consumer_key(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAssignConsumerKey>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAssignConsumerKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/AssignConsumerKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "AssignConsumerKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_consumer_misbehaviour(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSubmitConsumerMisbehaviour>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerMisbehaviourResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerMisbehaviour",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "SubmitConsumerMisbehaviour",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_consumer_double_voting(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSubmitConsumerDoubleVoting>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerDoubleVotingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerDoubleVoting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "SubmitConsumerDoubleVoting",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_consumer(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateConsumerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/CreateConsumer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "CreateConsumer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_consumer(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateConsumerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/UpdateConsumer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "UpdateConsumer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn remove_consumer(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRemoveConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRemoveConsumerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/RemoveConsumer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "RemoveConsumer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "UpdateParams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn opt_in(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgOptIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgOptInResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/OptIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("interchain_security.ccv.provider.v1.Msg", "OptIn"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn opt_out(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgOptOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgOptOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/OptOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("interchain_security.ccv.provider.v1.Msg", "OptOut"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_consumer_commission_rate(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSetConsumerCommissionRate>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSetConsumerCommissionRateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/SetConsumerCommissionRate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "SetConsumerCommissionRate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_reward_denoms(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgChangeRewardDenoms>,
        ) -> std::result::Result<
            tonic::Response<super::MsgChangeRewardDenomsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/ChangeRewardDenoms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "ChangeRewardDenoms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod msg_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: Send + Sync + 'static {
        async fn assign_consumer_key(
            &self,
            request: tonic::Request<super::MsgAssignConsumerKey>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAssignConsumerKeyResponse>,
            tonic::Status,
        >;
        async fn submit_consumer_misbehaviour(
            &self,
            request: tonic::Request<super::MsgSubmitConsumerMisbehaviour>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerMisbehaviourResponse>,
            tonic::Status,
        >;
        async fn submit_consumer_double_voting(
            &self,
            request: tonic::Request<super::MsgSubmitConsumerDoubleVoting>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerDoubleVotingResponse>,
            tonic::Status,
        >;
        async fn create_consumer(
            &self,
            request: tonic::Request<super::MsgCreateConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateConsumerResponse>,
            tonic::Status,
        >;
        async fn update_consumer(
            &self,
            request: tonic::Request<super::MsgUpdateConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateConsumerResponse>,
            tonic::Status,
        >;
        async fn remove_consumer(
            &self,
            request: tonic::Request<super::MsgRemoveConsumer>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRemoveConsumerResponse>,
            tonic::Status,
        >;
        async fn update_params(
            &self,
            request: tonic::Request<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        >;
        async fn opt_in(
            &self,
            request: tonic::Request<super::MsgOptIn>,
        ) -> std::result::Result<
            tonic::Response<super::MsgOptInResponse>,
            tonic::Status,
        >;
        async fn opt_out(
            &self,
            request: tonic::Request<super::MsgOptOut>,
        ) -> std::result::Result<
            tonic::Response<super::MsgOptOutResponse>,
            tonic::Status,
        >;
        async fn set_consumer_commission_rate(
            &self,
            request: tonic::Request<super::MsgSetConsumerCommissionRate>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSetConsumerCommissionRateResponse>,
            tonic::Status,
        >;
        async fn change_reward_denoms(
            &self,
            request: tonic::Request<super::MsgChangeRewardDenoms>,
        ) -> std::result::Result<
            tonic::Response<super::MsgChangeRewardDenomsResponse>,
            tonic::Status,
        >;
    }
    /// Msg defines the Msg service.
    #[derive(Debug)]
    pub struct MsgServer<T: Msg> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Msg> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/interchain_security.ccv.provider.v1.Msg/AssignConsumerKey" => {
                    #[allow(non_camel_case_types)]
                    struct AssignConsumerKeySvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgAssignConsumerKey>
                    for AssignConsumerKeySvc<T> {
                        type Response = super::MsgAssignConsumerKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgAssignConsumerKey>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::assign_consumer_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AssignConsumerKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerMisbehaviour" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitConsumerMisbehaviourSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSubmitConsumerMisbehaviour>
                    for SubmitConsumerMisbehaviourSvc<T> {
                        type Response = super::MsgSubmitConsumerMisbehaviourResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSubmitConsumerMisbehaviour>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::submit_consumer_misbehaviour(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitConsumerMisbehaviourSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerDoubleVoting" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitConsumerDoubleVotingSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSubmitConsumerDoubleVoting>
                    for SubmitConsumerDoubleVotingSvc<T> {
                        type Response = super::MsgSubmitConsumerDoubleVotingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSubmitConsumerDoubleVoting>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::submit_consumer_double_voting(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitConsumerDoubleVotingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/CreateConsumer" => {
                    #[allow(non_camel_case_types)]
                    struct CreateConsumerSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCreateConsumer>
                    for CreateConsumerSvc<T> {
                        type Response = super::MsgCreateConsumerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCreateConsumer>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::create_consumer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateConsumerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/UpdateConsumer" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateConsumerSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgUpdateConsumer>
                    for UpdateConsumerSvc<T> {
                        type Response = super::MsgUpdateConsumerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgUpdateConsumer>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::update_consumer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateConsumerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/RemoveConsumer" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveConsumerSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgRemoveConsumer>
                    for RemoveConsumerSvc<T> {
                        type Response = super::MsgRemoveConsumerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgRemoveConsumer>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::remove_consumer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveConsumerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/UpdateParams" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateParamsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgUpdateParams>
                    for UpdateParamsSvc<T> {
                        type Response = super::MsgUpdateParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgUpdateParams>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::update_params(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/OptIn" => {
                    #[allow(non_camel_case_types)]
                    struct OptInSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgOptIn>
                    for OptInSvc<T> {
                        type Response = super::MsgOptInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgOptIn>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::opt_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OptInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/OptOut" => {
                    #[allow(non_camel_case_types)]
                    struct OptOutSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgOptOut>
                    for OptOutSvc<T> {
                        type Response = super::MsgOptOutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgOptOut>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::opt_out(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OptOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/SetConsumerCommissionRate" => {
                    #[allow(non_camel_case_types)]
                    struct SetConsumerCommissionRateSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSetConsumerCommissionRate>
                    for SetConsumerCommissionRateSvc<T> {
                        type Response = super::MsgSetConsumerCommissionRateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSetConsumerCommissionRate>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::set_consumer_commission_rate(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetConsumerCommissionRateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/ChangeRewardDenoms" => {
                    #[allow(non_camel_case_types)]
                    struct ChangeRewardDenomsSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgChangeRewardDenoms>
                    for ChangeRewardDenomsSvc<T> {
                        type Response = super::MsgChangeRewardDenomsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgChangeRewardDenoms>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::change_reward_denoms(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChangeRewardDenomsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Msg> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Msg> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = "interchain_security.ccv.provider.v1.Msg";
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerGenesisRequest {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerGenesisRequest {
    const NAME: &'static str = "QueryConsumerGenesisRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerGenesisRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerGenesisRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerGenesisResponse {
    #[prost(message, optional, tag = "1")]
    pub genesis_state: ::core::option::Option<super::super::v1::ConsumerGenesisState>,
}
impl ::prost::Name for QueryConsumerGenesisResponse {
    const NAME: &'static str = "QueryConsumerGenesisResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerGenesisResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerGenesisResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsRequest {
    /// The phase of the consumer chains returned (optional)
    /// Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5
    #[prost(enumeration = "ConsumerPhase", tag = "1")]
    pub phase: i32,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryConsumerChainsRequest {
    const NAME: &'static str = "QueryConsumerChainsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsResponse {
    #[prost(message, repeated, tag = "1")]
    pub chains: ::prost::alloc::vec::Vec<Chain>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryConsumerChainsResponse {
    const NAME: &'static str = "QueryConsumerChainsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chain {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub top_n: u32,
    /// If the chain is a Top-N chain, this is the minimum power required to be in the top N.
    /// Otherwise, this is -1.
    #[prost(int64, tag = "4")]
    pub min_power_in_top_n: i64,
    /// Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain.
    #[prost(uint32, tag = "5")]
    pub validators_power_cap: u32,
    /// Corresponds to the maximum number of validators that can validate a consumer chain.
    /// Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
    #[prost(uint32, tag = "6")]
    pub validator_set_cap: u32,
    /// Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
    /// the consumer chain.
    #[prost(string, repeated, tag = "7")]
    pub allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
    #[prost(string, repeated, tag = "8")]
    pub denylist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The phase the consumer chain
    #[prost(string, tag = "9")]
    pub phase: ::prost::alloc::string::String,
    /// The metadata of the consumer chain
    #[prost(message, optional, tag = "10")]
    pub metadata: ::core::option::Option<ConsumerMetadata>,
    /// Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.
    #[prost(uint64, tag = "11")]
    pub min_stake: u64,
    /// Corresponds to whether inactive validators are allowed to validate the consumer chain.
    #[prost(bool, tag = "12")]
    pub allow_inactive_vals: bool,
    #[prost(string, tag = "13")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for Chain {
    const NAME: &'static str = "Chain";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.Chain".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.Chain".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerAddrRequest {
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
    /// The id of the consumer chain
    #[prost(string, tag = "2")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerAddrRequest {
    const NAME: &'static str = "QueryValidatorConsumerAddrRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerAddrResponse {
    /// The address of the validator on the consumer chain
    #[prost(string, tag = "1")]
    pub consumer_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerAddrResponse {
    const NAME: &'static str = "QueryValidatorConsumerAddrResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorProviderAddrRequest {
    /// The consensus address of the validator on the consumer chain
    #[prost(string, tag = "1")]
    pub consumer_address: ::prost::alloc::string::String,
    /// The id of the consumer chain
    #[prost(string, tag = "2")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorProviderAddrRequest {
    const NAME: &'static str = "QueryValidatorProviderAddrRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorProviderAddrRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorProviderAddrRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorProviderAddrResponse {
    /// The address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorProviderAddrResponse {
    const NAME: &'static str = "QueryValidatorProviderAddrResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorProviderAddrResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorProviderAddrResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryThrottleStateRequest {}
impl ::prost::Name for QueryThrottleStateRequest {
    const NAME: &'static str = "QueryThrottleStateRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottleStateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottleStateRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryThrottleStateResponse {
    /// current slash_meter state
    #[prost(int64, tag = "1")]
    pub slash_meter: i64,
    /// allowance of voting power units (int) that the slash meter is given per
    /// replenish period this also serves as the max value for the meter.
    #[prost(int64, tag = "2")]
    pub slash_meter_allowance: i64,
    /// next time the slash meter could potentially be replenished, iff it's not
    /// full
    #[prost(message, optional, tag = "3")]
    pub next_replenish_candidate: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
impl ::prost::Name for QueryThrottleStateResponse {
    const NAME: &'static str = "QueryThrottleStateResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottleStateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottleStateResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRegisteredConsumerRewardDenomsRequest {}
impl ::prost::Name for QueryRegisteredConsumerRewardDenomsRequest {
    const NAME: &'static str = "QueryRegisteredConsumerRewardDenomsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRegisteredConsumerRewardDenomsResponse {
    #[prost(string, repeated, tag = "1")]
    pub denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryRegisteredConsumerRewardDenomsResponse {
    const NAME: &'static str = "QueryRegisteredConsumerRewardDenomsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPairsValConsAddrByConsumerRequest {
    /// The id of the consumer chain
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryAllPairsValConsAddrByConsumerRequest {
    const NAME: &'static str = "QueryAllPairsValConsAddrByConsumerRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryAllPairsValConsAddrByConsumerRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryAllPairsValConsAddrByConsumerRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPairsValConsAddrByConsumerResponse {
    #[prost(message, repeated, tag = "1")]
    pub pair_val_con_addr: ::prost::alloc::vec::Vec<PairValConAddrProviderAndConsumer>,
}
impl ::prost::Name for QueryAllPairsValConsAddrByConsumerResponse {
    const NAME: &'static str = "QueryAllPairsValConsAddrByConsumerResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryAllPairsValConsAddrByConsumerResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryAllPairsValConsAddrByConsumerResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairValConAddrProviderAndConsumer {
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
    /// The consensus address of the validator on the consumer chain
    #[prost(string, tag = "2")]
    pub consumer_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub consumer_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
}
impl ::prost::Name for PairValConAddrProviderAndConsumer {
    const NAME: &'static str = "PairValConAddrProviderAndConsumer";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.PairValConAddrProviderAndConsumer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.PairValConAddrProviderAndConsumer".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryParamsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryParamsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainOptedInValidatorsRequest {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerChainOptedInValidatorsRequest {
    const NAME: &'static str = "QueryConsumerChainOptedInValidatorsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainOptedInValidatorsRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainOptedInValidatorsRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainOptedInValidatorsResponse {
    /// The consensus addresses of the validators on the provider chain
    #[prost(string, repeated, tag = "1")]
    pub validators_provider_addresses: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for QueryConsumerChainOptedInValidatorsResponse {
    const NAME: &'static str = "QueryConsumerChainOptedInValidatorsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainOptedInValidatorsResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainOptedInValidatorsResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerValidatorsRequest {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerValidatorsRequest {
    const NAME: &'static str = "QueryConsumerValidatorsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerValidatorsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerValidatorsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerValidatorsValidator {
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
    /// The consumer public key of the validator used on the consumer chain
    #[prost(message, optional, tag = "2")]
    pub consumer_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
    /// \[DEPRECATED\] use `consumer_power` instead
    #[deprecated]
    #[prost(int64, tag = "3")]
    pub power: i64,
    /// \[DEPRECATED\] use `consumer_commission_rate` instead
    #[deprecated]
    #[prost(string, tag = "4")]
    pub rate: ::prost::alloc::string::String,
    /// The power of the validator used on the consumer chain
    #[prost(int64, tag = "5")]
    pub consumer_power: i64,
    /// The rate to charge delegators on the consumer chain, as a fraction
    #[prost(string, tag = "6")]
    pub consumer_commission_rate: ::prost::alloc::string::String,
    /// The rate to charge delegators on the provider chain, as a fraction
    #[prost(string, tag = "7")]
    pub provider_commission_rate: ::prost::alloc::string::String,
    /// description defines the description terms for the validator
    #[prost(message, optional, tag = "8")]
    pub description: ::core::option::Option<
        super::super::super::super::cosmos::staking::v1beta1::Description,
    >,
    /// provider_operator_address defines the address of the validator's operator
    #[prost(string, tag = "9")]
    pub provider_operator_address: ::prost::alloc::string::String,
    /// jailed defined whether the validator has been jailed from bonded status or not.
    #[prost(bool, tag = "10")]
    pub jailed: bool,
    /// status is the validator status (bonded/unbonding/unbonded).
    #[prost(
        enumeration = "super::super::super::super::cosmos::staking::v1beta1::BondStatus",
        tag = "11"
    )]
    pub status: i32,
    /// provider_tokens defines the delegated tokens (incl. self-delegation).
    #[prost(string, tag = "12")]
    pub provider_tokens: ::prost::alloc::string::String,
    /// The power of the validator used on the provider chain
    #[prost(int64, tag = "13")]
    pub provider_power: i64,
    /// validates_current_epoch defines whether the validator has to validate for the current epoch or not
    #[prost(bool, tag = "14")]
    pub validates_current_epoch: bool,
}
impl ::prost::Name for QueryConsumerValidatorsValidator {
    const NAME: &'static str = "QueryConsumerValidatorsValidator";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerValidatorsValidator".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerValidatorsValidator".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerValidatorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub validators: ::prost::alloc::vec::Vec<QueryConsumerValidatorsValidator>,
}
impl ::prost::Name for QueryConsumerValidatorsResponse {
    const NAME: &'static str = "QueryConsumerValidatorsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerValidatorsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerValidatorsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsValidatorHasToValidateRequest {
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerChainsValidatorHasToValidateRequest {
    const NAME: &'static str = "QueryConsumerChainsValidatorHasToValidateRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsValidatorHasToValidateRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsValidatorHasToValidateRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsValidatorHasToValidateResponse {
    #[prost(string, repeated, tag = "1")]
    pub consumer_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryConsumerChainsValidatorHasToValidateResponse {
    const NAME: &'static str = "QueryConsumerChainsValidatorHasToValidateResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsValidatorHasToValidateResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsValidatorHasToValidateResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerCommissionRateRequest {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "2")]
    pub provider_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerCommissionRateRequest {
    const NAME: &'static str = "QueryValidatorConsumerCommissionRateRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerCommissionRateRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerCommissionRateRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerCommissionRateResponse {
    /// The rate to charge delegators on the consumer chain, as a fraction
    #[prost(string, tag = "1")]
    pub rate: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerCommissionRateResponse {
    const NAME: &'static str = "QueryValidatorConsumerCommissionRateResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerCommissionRateResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerCommissionRateResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBlocksUntilNextEpochRequest {}
impl ::prost::Name for QueryBlocksUntilNextEpochRequest {
    const NAME: &'static str = "QueryBlocksUntilNextEpochRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryBlocksUntilNextEpochRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryBlocksUntilNextEpochRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBlocksUntilNextEpochResponse {
    /// The number of blocks until the next epoch starts
    #[prost(uint64, tag = "1")]
    pub blocks_until_next_epoch: u64,
}
impl ::prost::Name for QueryBlocksUntilNextEpochResponse {
    const NAME: &'static str = "QueryBlocksUntilNextEpochResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryBlocksUntilNextEpochResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryBlocksUntilNextEpochResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerIdFromClientIdRequest {
    /// the client id (on the provider) that is tracking the consumer chain
    /// the client id can be found from the consumer chain by querying (i.e., `query ccvconsumer provider-info`)
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerIdFromClientIdRequest {
    const NAME: &'static str = "QueryConsumerIdFromClientIdRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerIdFromClientIdRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerIdFromClientIdRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerIdFromClientIdResponse {
    /// the consumer id of the chain associated with this client id
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerIdFromClientIdResponse {
    const NAME: &'static str = "QueryConsumerIdFromClientIdResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerIdFromClientIdResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerIdFromClientIdResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainRequest {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerChainRequest {
    const NAME: &'static str = "QueryConsumerChainRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainResponse {
    #[prost(string, tag = "1")]
    pub consumer_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub phase: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<ConsumerMetadata>,
    #[prost(message, optional, tag = "6")]
    pub init_params: ::core::option::Option<ConsumerInitializationParameters>,
    #[prost(message, optional, tag = "7")]
    pub power_shaping_params: ::core::option::Option<PowerShapingParameters>,
}
impl ::prost::Name for QueryConsumerChainResponse {
    const NAME: &'static str = "QueryConsumerChainResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainResponse".into()
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod query_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ConsumerGenesis queries the genesis state needed to start a consumer chain
        /// whose proposal has been accepted
        pub async fn query_consumer_genesis(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerGenesisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerGenesisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerGenesis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ConsumerChains queries active consumer chains supported by the provider
        /// chain
        pub async fn query_consumer_chains(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerChainsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChains",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChains",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryValidatorConsumerAddr queries the address
        /// assigned by a validator for a consumer chain.
        pub async fn query_validator_consumer_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidatorConsumerAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerAddrResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryValidatorConsumerAddr",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryProviderAddr returns the provider chain validator
        /// given a consumer chain validator address
        pub async fn query_validator_provider_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidatorProviderAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorProviderAddrResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryValidatorProviderAddr",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryThrottleState returns the main on-chain state relevant to currently
        /// throttled slash packets
        pub async fn query_throttle_state(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryThrottleStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottleStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryThrottleState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryThrottleState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
        /// denoms that are registered
        pub async fn query_registered_consumer_reward_denoms(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryRegisteredConsumerRewardDenomsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryRegisteredConsumerRewardDenomsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryRegisteredConsumerRewardDenoms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryAllPairsValConsAddrByConsumer returns a list of pair valconsensus address
        /// between provider and consumer chain
        pub async fn query_all_pairs_val_cons_addr_by_consumer(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryAllPairsValConsAddrByConsumerRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPairsValConsAddrByConsumerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryAllPairsValConsAddrByConsumer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryParams returns all current values of provider parameters
        pub async fn query_params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryParams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerChainOptedInValidators returns a list of validators consensus addresses
        /// that opted-in to the given consumer chain
        pub async fn query_consumer_chain_opted_in_validators(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryConsumerChainOptedInValidatorsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainOptedInValidatorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChainOptedInValidators",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerChainsValidatorHasToValidate returns a list of consumer chains
        /// that a given validator must validate
        pub async fn query_consumer_chains_validator_has_to_validate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryConsumerChainsValidatorHasToValidateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsValidatorHasToValidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChainsValidatorHasToValidate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryValidatorConsumerCommissionRate returns the commission rate a given
        /// validator charges on a given consumer chain
        pub async fn query_validator_consumer_commission_rate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryValidatorConsumerCommissionRateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerCommissionRateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryValidatorConsumerCommissionRate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerValidators returns the latest set consumer-validator set for a given consumer ID
        /// Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment
        /// because a VSCPacket could be delayed to be delivered on the consumer chain.
        pub async fn query_consumer_validators(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerValidatorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerValidatorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerValidators",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerValidators",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryBlocksUntilNextEpoch returns the number of blocks until the next epoch
        /// starts and validator updates are sent to the consumer chains
        pub async fn query_blocks_until_next_epoch(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBlocksUntilNextEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBlocksUntilNextEpochResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryBlocksUntilNextEpoch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerIdFromClientId returns the consumer id of the chain
        /// associated with the provided client id
        pub async fn query_consumer_id_from_client_id(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerIdFromClientIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerIdFromClientIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerIdFromClientId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerChain returns the consumer chain
        /// associated with the provided consumer id
        pub async fn query_consumer_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChain",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod query_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServer.
    #[async_trait]
    pub trait Query: Send + Sync + 'static {
        /// ConsumerGenesis queries the genesis state needed to start a consumer chain
        /// whose proposal has been accepted
        async fn query_consumer_genesis(
            &self,
            request: tonic::Request<super::QueryConsumerGenesisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerGenesisResponse>,
            tonic::Status,
        >;
        /// ConsumerChains queries active consumer chains supported by the provider
        /// chain
        async fn query_consumer_chains(
            &self,
            request: tonic::Request<super::QueryConsumerChainsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsResponse>,
            tonic::Status,
        >;
        /// QueryValidatorConsumerAddr queries the address
        /// assigned by a validator for a consumer chain.
        async fn query_validator_consumer_addr(
            &self,
            request: tonic::Request<super::QueryValidatorConsumerAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerAddrResponse>,
            tonic::Status,
        >;
        /// QueryProviderAddr returns the provider chain validator
        /// given a consumer chain validator address
        async fn query_validator_provider_addr(
            &self,
            request: tonic::Request<super::QueryValidatorProviderAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorProviderAddrResponse>,
            tonic::Status,
        >;
        /// QueryThrottleState returns the main on-chain state relevant to currently
        /// throttled slash packets
        async fn query_throttle_state(
            &self,
            request: tonic::Request<super::QueryThrottleStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottleStateResponse>,
            tonic::Status,
        >;
        /// QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
        /// denoms that are registered
        async fn query_registered_consumer_reward_denoms(
            &self,
            request: tonic::Request<super::QueryRegisteredConsumerRewardDenomsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryRegisteredConsumerRewardDenomsResponse>,
            tonic::Status,
        >;
        /// QueryAllPairsValConsAddrByConsumer returns a list of pair valconsensus address
        /// between provider and consumer chain
        async fn query_all_pairs_val_cons_addr_by_consumer(
            &self,
            request: tonic::Request<super::QueryAllPairsValConsAddrByConsumerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPairsValConsAddrByConsumerResponse>,
            tonic::Status,
        >;
        /// QueryParams returns all current values of provider parameters
        async fn query_params(
            &self,
            request: tonic::Request<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        >;
        /// QueryConsumerChainOptedInValidators returns a list of validators consensus addresses
        /// that opted-in to the given consumer chain
        async fn query_consumer_chain_opted_in_validators(
            &self,
            request: tonic::Request<super::QueryConsumerChainOptedInValidatorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainOptedInValidatorsResponse>,
            tonic::Status,
        >;
        /// QueryConsumerChainsValidatorHasToValidate returns a list of consumer chains
        /// that a given validator must validate
        async fn query_consumer_chains_validator_has_to_validate(
            &self,
            request: tonic::Request<
                super::QueryConsumerChainsValidatorHasToValidateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsValidatorHasToValidateResponse>,
            tonic::Status,
        >;
        /// QueryValidatorConsumerCommissionRate returns the commission rate a given
        /// validator charges on a given consumer chain
        async fn query_validator_consumer_commission_rate(
            &self,
            request: tonic::Request<super::QueryValidatorConsumerCommissionRateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerCommissionRateResponse>,
            tonic::Status,
        >;
        /// QueryConsumerValidators returns the latest set consumer-validator set for a given consumer ID
        /// Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment
        /// because a VSCPacket could be delayed to be delivered on the consumer chain.
        async fn query_consumer_validators(
            &self,
            request: tonic::Request<super::QueryConsumerValidatorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerValidatorsResponse>,
            tonic::Status,
        >;
        /// QueryBlocksUntilNextEpoch returns the number of blocks until the next epoch
        /// starts and validator updates are sent to the consumer chains
        async fn query_blocks_until_next_epoch(
            &self,
            request: tonic::Request<super::QueryBlocksUntilNextEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBlocksUntilNextEpochResponse>,
            tonic::Status,
        >;
        /// QueryConsumerIdFromClientId returns the consumer id of the chain
        /// associated with the provided client id
        async fn query_consumer_id_from_client_id(
            &self,
            request: tonic::Request<super::QueryConsumerIdFromClientIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerIdFromClientIdResponse>,
            tonic::Status,
        >;
        /// QueryConsumerChain returns the consumer chain
        /// associated with the provided consumer id
        async fn query_consumer_chain(
            &self,
            request: tonic::Request<super::QueryConsumerChainRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct QueryServer<T: Query> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Query> QueryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServer<T>
    where
        T: Query,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerGenesisSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerGenesisRequest>
                    for QueryConsumerGenesisSvc<T> {
                        type Response = super::QueryConsumerGenesisResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryConsumerGenesisRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_genesis(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerGenesisSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChains" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerChainsRequest>
                    for QueryConsumerChainsSvc<T> {
                        type Response = super::QueryConsumerChainsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryConsumerChainsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chains(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr" => {
                    #[allow(non_camel_case_types)]
                    struct QueryValidatorConsumerAddrSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryValidatorConsumerAddrRequest,
                    > for QueryValidatorConsumerAddrSvc<T> {
                        type Response = super::QueryValidatorConsumerAddrResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryValidatorConsumerAddrRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_validator_consumer_addr(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryValidatorConsumerAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr" => {
                    #[allow(non_camel_case_types)]
                    struct QueryValidatorProviderAddrSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryValidatorProviderAddrRequest,
                    > for QueryValidatorProviderAddrSvc<T> {
                        type Response = super::QueryValidatorProviderAddrResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryValidatorProviderAddrRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_validator_provider_addr(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryValidatorProviderAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryThrottleState" => {
                    #[allow(non_camel_case_types)]
                    struct QueryThrottleStateSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryThrottleStateRequest>
                    for QueryThrottleStateSvc<T> {
                        type Response = super::QueryThrottleStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryThrottleStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_throttle_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryThrottleStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms" => {
                    #[allow(non_camel_case_types)]
                    struct QueryRegisteredConsumerRewardDenomsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryRegisteredConsumerRewardDenomsRequest,
                    > for QueryRegisteredConsumerRewardDenomsSvc<T> {
                        type Response = super::QueryRegisteredConsumerRewardDenomsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryRegisteredConsumerRewardDenomsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_registered_consumer_reward_denoms(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryRegisteredConsumerRewardDenomsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer" => {
                    #[allow(non_camel_case_types)]
                    struct QueryAllPairsValConsAddrByConsumerSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryAllPairsValConsAddrByConsumerRequest,
                    > for QueryAllPairsValConsAddrByConsumerSvc<T> {
                        type Response = super::QueryAllPairsValConsAddrByConsumerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryAllPairsValConsAddrByConsumerRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_all_pairs_val_cons_addr_by_consumer(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryAllPairsValConsAddrByConsumerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryParams" => {
                    #[allow(non_camel_case_types)]
                    struct QueryParamsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryParamsRequest>
                    for QueryParamsSvc<T> {
                        type Response = super::QueryParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_params(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryParamsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainOptedInValidatorsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryConsumerChainOptedInValidatorsRequest,
                    > for QueryConsumerChainOptedInValidatorsSvc<T> {
                        type Response = super::QueryConsumerChainOptedInValidatorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerChainOptedInValidatorsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chain_opted_in_validators(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainOptedInValidatorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainsValidatorHasToValidateSvc<T: Query>(
                        pub Arc<T>,
                    );
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryConsumerChainsValidatorHasToValidateRequest,
                    > for QueryConsumerChainsValidatorHasToValidateSvc<T> {
                        type Response = super::QueryConsumerChainsValidatorHasToValidateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerChainsValidatorHasToValidateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chains_validator_has_to_validate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainsValidatorHasToValidateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate" => {
                    #[allow(non_camel_case_types)]
                    struct QueryValidatorConsumerCommissionRateSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryValidatorConsumerCommissionRateRequest,
                    > for QueryValidatorConsumerCommissionRateSvc<T> {
                        type Response = super::QueryValidatorConsumerCommissionRateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryValidatorConsumerCommissionRateRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_validator_consumer_commission_rate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryValidatorConsumerCommissionRateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerValidators" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerValidatorsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerValidatorsRequest>
                    for QueryConsumerValidatorsSvc<T> {
                        type Response = super::QueryConsumerValidatorsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerValidatorsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_validators(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerValidatorsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch" => {
                    #[allow(non_camel_case_types)]
                    struct QueryBlocksUntilNextEpochSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryBlocksUntilNextEpochRequest,
                    > for QueryBlocksUntilNextEpochSvc<T> {
                        type Response = super::QueryBlocksUntilNextEpochResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryBlocksUntilNextEpochRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_blocks_until_next_epoch(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryBlocksUntilNextEpochSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerIdFromClientIdSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryConsumerIdFromClientIdRequest,
                    > for QueryConsumerIdFromClientIdSvc<T> {
                        type Response = super::QueryConsumerIdFromClientIdResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerIdFromClientIdRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_id_from_client_id(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerIdFromClientIdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChain" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerChainRequest>
                    for QueryConsumerChainSvc<T> {
                        type Response = super::QueryConsumerChainResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryConsumerChainRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chain(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Query> Clone for QueryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Query> tonic::server::NamedService for QueryServer<T> {
        const NAME: &'static str = "interchain_security.ccv.provider.v1.Query";
    }
}
/// GenesisState defines the CCV provider chain genesis state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// strictly positive and set to 1 (DefaultValsetUpdateID) for a new chain
    #[prost(uint64, tag = "1")]
    pub valset_update_id: u64,
    /// empty for a new chain
    #[prost(message, repeated, tag = "2")]
    pub consumer_states: ::prost::alloc::vec::Vec<ConsumerState>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "5")]
    pub valset_update_id_to_height: ::prost::alloc::vec::Vec<ValsetUpdateIdToHeight>,
    #[prost(message, optional, tag = "8")]
    pub params: ::core::option::Option<Params>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "9")]
    pub validator_consumer_pubkeys: ::prost::alloc::vec::Vec<ValidatorConsumerPubKey>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "10")]
    pub validators_by_consumer_addr: ::prost::alloc::vec::Vec<ValidatorByConsumerAddr>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "14")]
    pub consumer_addrs_to_prune_v2: ::prost::alloc::vec::Vec<ConsumerAddrsToPruneV2>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.GenesisState".into()
    }
}
/// The provider CCV module's knowledge of consumer state.
///
/// Note this type is only used internally to the provider CCV module.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerState {
    /// ChainID defines the chain ID for the consumer chain
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// ChannelID defines the IBC channel ID for the consumer chain
    #[prost(string, tag = "2")]
    pub channel_id: ::prost::alloc::string::String,
    /// ClientID defines the IBC client ID for the consumer chain
    #[prost(string, tag = "3")]
    pub client_id: ::prost::alloc::string::String,
    /// InitalHeight defines the initial block height for the consumer chain
    #[prost(uint64, tag = "4")]
    pub initial_height: u64,
    /// ConsumerGenesis defines the initial consumer chain genesis states
    #[prost(message, optional, tag = "5")]
    pub consumer_genesis: ::core::option::Option<super::super::v1::ConsumerGenesisState>,
    /// PendingValsetChanges defines the pending validator set changes for the
    /// consumer chain
    #[prost(message, repeated, tag = "6")]
    pub pending_valset_changes: ::prost::alloc::vec::Vec<
        super::super::v1::ValidatorSetChangePacketData,
    >,
    #[prost(string, repeated, tag = "7")]
    pub slash_downtime_ack: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the phase of the consumer chain
    #[prost(enumeration = "ConsumerPhase", tag = "9")]
    pub phase: i32,
}
impl ::prost::Name for ConsumerState {
    const NAME: &'static str = "ConsumerState";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerState".into()
    }
}
/// ValsetUpdateIdToHeight defines the genesis information for the mapping
/// of each valset update id to a block height
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValsetUpdateIdToHeight {
    #[prost(uint64, tag = "1")]
    pub valset_update_id: u64,
    #[prost(uint64, tag = "2")]
    pub height: u64,
}
impl ::prost::Name for ValsetUpdateIdToHeight {
    const NAME: &'static str = "ValsetUpdateIdToHeight";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValsetUpdateIdToHeight".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValsetUpdateIdToHeight".into()
    }
}
