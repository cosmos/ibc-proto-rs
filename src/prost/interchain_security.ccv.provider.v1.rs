// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAssignConsumerKey {
    /// The chain id of the consumer chain to assign a consensus public key to
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// The validator address on the provider
    #[prost(string, tag = "2")]
    pub provider_addr: ::prost::alloc::string::String,
    /// The consensus public key to use on the consumer.
    /// in json string format corresponding to proto-any, ex:
    /// `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`
    #[prost(string, tag = "3")]
    pub consumer_key: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAssignConsumerKey {
    const NAME: &'static str = "MsgAssignConsumerKey";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgAssignConsumerKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgAssignConsumerKey".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAssignConsumerKeyResponse {}
impl ::prost::Name for MsgAssignConsumerKeyResponse {
    const NAME: &'static str = "MsgAssignConsumerKeyResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgAssignConsumerKeyResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgAssignConsumerKeyResponse".into()
    }
}
/// MsgSubmitConsumerMisbehaviour defines a message that reports a light client attack,
///   also known as a misbehaviour, observed on a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerMisbehaviour {
    #[prost(string, tag = "1")]
    pub submitter: ::prost::alloc::string::String,
    /// The Misbehaviour of the consumer chain wrapping
    /// two conflicting IBC headers
    #[prost(message, optional, tag = "2")]
    pub misbehaviour: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::Misbehaviour,
    >,
}
impl ::prost::Name for MsgSubmitConsumerMisbehaviour {
    const NAME: &'static str = "MsgSubmitConsumerMisbehaviour";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviour".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviour".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerMisbehaviourResponse {}
impl ::prost::Name for MsgSubmitConsumerMisbehaviourResponse {
    const NAME: &'static str = "MsgSubmitConsumerMisbehaviourResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviourResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerMisbehaviourResponse"
            .into()
    }
}
/// MsgSubmitConsumerDoubleVoting defines a message that reports
/// a double signing infraction observed on a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerDoubleVoting {
    #[prost(string, tag = "1")]
    pub submitter: ::prost::alloc::string::String,
    /// The equivocation of the consumer chain wrapping
    /// an evidence of a validator that signed two conflicting votes
    #[prost(message, optional, tag = "2")]
    pub duplicate_vote_evidence: ::core::option::Option<
        ::tendermint_proto::types::DuplicateVoteEvidence,
    >,
    /// The light client header of the infraction block
    #[prost(message, optional, tag = "3")]
    pub infraction_block_header: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::Header,
    >,
}
impl ::prost::Name for MsgSubmitConsumerDoubleVoting {
    const NAME: &'static str = "MsgSubmitConsumerDoubleVoting";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVoting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVoting".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSubmitConsumerDoubleVotingResponse {}
impl ::prost::Name for MsgSubmitConsumerDoubleVotingResponse {
    const NAME: &'static str = "MsgSubmitConsumerDoubleVotingResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVotingResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MsgSubmitConsumerDoubleVotingResponse"
            .into()
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod msg_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn assign_consumer_key(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAssignConsumerKey>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAssignConsumerKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/AssignConsumerKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "AssignConsumerKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_consumer_misbehaviour(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSubmitConsumerMisbehaviour>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerMisbehaviourResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerMisbehaviour",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "SubmitConsumerMisbehaviour",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_consumer_double_voting(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSubmitConsumerDoubleVoting>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerDoubleVotingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerDoubleVoting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Msg",
                        "SubmitConsumerDoubleVoting",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod msg_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: Send + Sync + 'static {
        async fn assign_consumer_key(
            &self,
            request: tonic::Request<super::MsgAssignConsumerKey>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAssignConsumerKeyResponse>,
            tonic::Status,
        >;
        async fn submit_consumer_misbehaviour(
            &self,
            request: tonic::Request<super::MsgSubmitConsumerMisbehaviour>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerMisbehaviourResponse>,
            tonic::Status,
        >;
        async fn submit_consumer_double_voting(
            &self,
            request: tonic::Request<super::MsgSubmitConsumerDoubleVoting>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSubmitConsumerDoubleVotingResponse>,
            tonic::Status,
        >;
    }
    /// Msg defines the Msg service.
    #[derive(Debug)]
    pub struct MsgServer<T: Msg> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Msg> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/interchain_security.ccv.provider.v1.Msg/AssignConsumerKey" => {
                    #[allow(non_camel_case_types)]
                    struct AssignConsumerKeySvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgAssignConsumerKey>
                    for AssignConsumerKeySvc<T> {
                        type Response = super::MsgAssignConsumerKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgAssignConsumerKey>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::assign_consumer_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AssignConsumerKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerMisbehaviour" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitConsumerMisbehaviourSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSubmitConsumerMisbehaviour>
                    for SubmitConsumerMisbehaviourSvc<T> {
                        type Response = super::MsgSubmitConsumerMisbehaviourResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSubmitConsumerMisbehaviour>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::submit_consumer_misbehaviour(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitConsumerMisbehaviourSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Msg/SubmitConsumerDoubleVoting" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitConsumerDoubleVotingSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgSubmitConsumerDoubleVoting>
                    for SubmitConsumerDoubleVotingSvc<T> {
                        type Response = super::MsgSubmitConsumerDoubleVotingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgSubmitConsumerDoubleVoting>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::submit_consumer_double_voting(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitConsumerDoubleVotingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Msg> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Msg> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = "interchain_security.ccv.provider.v1.Msg";
    }
}
/// ConsumerAdditionProposal is a governance proposal on the provider chain to
/// spawn a new consumer chain. If it passes, then all validators on the provider
/// chain are expected to validate the consumer chain at spawn time or get
/// slashed. It is recommended that spawn time occurs after the proposal end
/// time.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAdditionProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the proposed chain-id of the new consumer chain, must be different from all
    /// other consumer chain ids of the executing provider chain.
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// the proposed initial height of new consumer chain.
    /// For a completely new chain, this will be {0,1}. However, it may be
    /// different if this is a chain that is converting to a consumer chain.
    #[prost(message, optional, tag = "4")]
    pub initial_height: ::core::option::Option<
        super::super::super::super::ibc::core::client::v1::Height,
    >,
    /// The hash of the consumer chain genesis state without the consumer CCV
    /// module genesis params. It is used for off-chain confirmation of
    /// genesis.json validity by validators and other parties.
    #[prost(bytes = "vec", tag = "5")]
    pub genesis_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the consumer chain binary that should be run by validators on
    /// chain initialization. It is used for off-chain confirmation of binary
    /// validity by validators and other parties.
    #[prost(bytes = "vec", tag = "6")]
    pub binary_hash: ::prost::alloc::vec::Vec<u8>,
    /// spawn time is the time on the provider chain at which the consumer chain
    /// genesis is finalized and all validators will be responsible for starting
    /// their consumer chain validator node.
    #[prost(message, optional, tag = "7")]
    pub spawn_time: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
    /// Unbonding period for the consumer,
    /// which should be smaller than that of the provider in general.
    #[prost(message, optional, tag = "8")]
    pub unbonding_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// Sent CCV related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "9")]
    pub ccv_timeout_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// Sent transfer related IBC packets will timeout after this duration
    #[prost(message, optional, tag = "10")]
    pub transfer_timeout_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// The fraction of tokens allocated to the consumer redistribution address
    /// during distribution events. The fraction is a string representing a
    /// decimal number. For example "0.75" would represent 75%.
    #[prost(string, tag = "11")]
    pub consumer_redistribution_fraction: ::prost::alloc::string::String,
    /// BlocksPerDistributionTransmission is the number of blocks between
    /// ibc-token-transfers from the consumer chain to the provider chain. On
    /// sending transmission event, `consumer_redistribution_fraction` of the
    /// accumulated tokens are sent to the consumer redistribution address.
    #[prost(int64, tag = "12")]
    pub blocks_per_distribution_transmission: i64,
    /// The number of historical info entries to persist in store.
    /// This param is a part of the cosmos sdk staking module. In the case of
    /// a ccv enabled consumer chain, the ccv module acts as the staking module.
    #[prost(int64, tag = "13")]
    pub historical_entries: i64,
    /// The ID of a token transfer channel used for the Reward Distribution
    /// sub-protocol. If DistributionTransmissionChannel == "", a new transfer
    /// channel is created on top of the same connection as the CCV channel.
    /// Note that transfer_channel_id is the ID of the channel end on the consumer
    /// chain. it is most relevant for chains performing a sovereign to consumer
    /// changeover in order to maintan the existing ibc transfer channel
    #[prost(string, tag = "14")]
    pub distribution_transmission_channel: ::prost::alloc::string::String,
}
impl ::prost::Name for ConsumerAdditionProposal {
    const NAME: &'static str = "ConsumerAdditionProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAdditionProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAdditionProposal".into()
    }
}
/// ConsumerRemovalProposal is a governance proposal on the provider chain to
/// remove (and stop) a consumer chain. If it passes, all the consumer chain's
/// state is removed from the provider chain. The outstanding unbonding operation
/// funds are released.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerRemovalProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the chain-id of the consumer chain to be stopped
    #[prost(string, tag = "3")]
    pub chain_id: ::prost::alloc::string::String,
    /// the time on the provider chain at which all validators are responsible to
    /// stop their consumer chain validator node
    #[prost(message, optional, tag = "4")]
    pub stop_time: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
}
impl ::prost::Name for ConsumerRemovalProposal {
    const NAME: &'static str = "ConsumerRemovalProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerRemovalProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerRemovalProposal".into()
    }
}
/// ChangeRewardDenomsProposal is a governance proposal on the provider chain to
/// mutate the set of denoms accepted by the provider as rewards.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeRewardDenomsProposal {
    /// the title of the proposal
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// the description of the proposal
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// the list of consumer reward denoms to add
    #[prost(string, repeated, tag = "3")]
    pub denoms_to_add: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of consumer reward denoms to remove
    #[prost(string, repeated, tag = "4")]
    pub denoms_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ChangeRewardDenomsProposal {
    const NAME: &'static str = "ChangeRewardDenomsProposal";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ChangeRewardDenomsProposal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ChangeRewardDenomsProposal".into()
    }
}
/// A persisted queue entry indicating that a slash packet data instance needs to
/// be handled. This type belongs in the "global" queue, to coordinate slash
/// packet handling times between consumers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSlashEntry {
    /// Block time that slash packet was received by provider chain.
    /// This field is used for store key iteration ordering.
    #[prost(message, optional, tag = "1")]
    pub recv_time: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
    /// The consumer that sent a slash packet.
    #[prost(string, tag = "2")]
    pub consumer_chain_id: ::prost::alloc::string::String,
    /// The IBC sequence number of the recv packet.
    /// This field is used in the store key to ensure uniqueness.
    #[prost(uint64, tag = "3")]
    pub ibc_seq_num: u64,
    /// The provider's consensus address of the validator being slashed.
    /// This field is used to obtain validator power in HandleThrottleQueues.
    ///
    /// This field is not used in the store key, but is persisted in value bytes,
    /// see QueueGlobalSlashEntry.
    #[prost(bytes = "vec", tag = "4")]
    pub provider_val_cons_addr: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for GlobalSlashEntry {
    const NAME: &'static str = "GlobalSlashEntry";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.GlobalSlashEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.GlobalSlashEntry".into()
    }
}
/// Params defines the parameters for CCV Provider module
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    #[prost(message, optional, tag = "1")]
    pub template_client: ::core::option::Option<
        super::super::super::super::ibc::lightclients::tendermint::v1::ClientState,
    >,
    /// TrustingPeriodFraction is used to compute the consumer and provider IBC
    /// client's TrustingPeriod from the chain defined UnbondingPeriod
    #[prost(string, tag = "2")]
    pub trusting_period_fraction: ::prost::alloc::string::String,
    /// Sent IBC packets will timeout after this duration
    #[prost(message, optional, tag = "3")]
    pub ccv_timeout_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// The channel initialization (IBC channel opening handshake) will timeout
    /// after this duration
    #[prost(message, optional, tag = "4")]
    pub init_timeout_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// The VSC packets sent by the provider will timeout after this duration.
    /// Note that unlike ccv_timeout_period which is an IBC param,
    /// the vsc_timeout_period is a provider-side param that enables the provider
    /// to timeout VSC packets even when a consumer chain is not live.
    #[prost(message, optional, tag = "5")]
    pub vsc_timeout_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// The period for which the slash meter is replenished
    #[prost(message, optional, tag = "6")]
    pub slash_meter_replenish_period: ::core::option::Option<
        super::super::super::super::google::protobuf::Duration,
    >,
    /// The fraction of total voting power that is replenished to the slash meter
    /// every replenish period. This param also serves as a maximum fraction of
    /// total voting power that the slash meter can hold.
    #[prost(string, tag = "7")]
    pub slash_meter_replenish_fraction: ::prost::alloc::string::String,
    /// The maximum amount of throttled slash or vsc matured packets
    /// that can be queued for a single consumer before the provider chain halts.
    #[prost(int64, tag = "8")]
    pub max_throttled_packets: i64,
    /// The fee required to be paid to add a reward denom
    #[prost(message, optional, tag = "9")]
    pub consumer_reward_denom_registration_fee: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.Params".into()
    }
}
/// SlashAcks contains cons addresses of consumer chain validators
/// successfully slashed on the provider chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlashAcks {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for SlashAcks {
    const NAME: &'static str = "SlashAcks";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.SlashAcks".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.SlashAcks".into()
    }
}
/// ConsumerAdditionProposals holds pending governance proposals on the provider
/// chain to spawn a new chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAdditionProposals {
    /// proposals waiting for spawn_time to pass
    #[prost(message, repeated, tag = "1")]
    pub pending: ::prost::alloc::vec::Vec<ConsumerAdditionProposal>,
}
impl ::prost::Name for ConsumerAdditionProposals {
    const NAME: &'static str = "ConsumerAdditionProposals";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAdditionProposals".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAdditionProposals".into()
    }
}
/// ConsumerRemovalProposals holds pending governance proposals on the provider
/// chain to remove (and stop) a consumer chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerRemovalProposals {
    /// proposals waiting for stop_time to pass
    #[prost(message, repeated, tag = "1")]
    pub pending: ::prost::alloc::vec::Vec<ConsumerRemovalProposal>,
}
impl ::prost::Name for ConsumerRemovalProposals {
    const NAME: &'static str = "ConsumerRemovalProposals";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerRemovalProposals".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerRemovalProposals".into()
    }
}
/// AddressList contains a list of consensus addresses
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressList {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for AddressList {
    const NAME: &'static str = "AddressList";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.AddressList".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.AddressList".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelToChain {
    #[prost(string, tag = "1")]
    pub channel_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
}
impl ::prost::Name for ChannelToChain {
    const NAME: &'static str = "ChannelToChain";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ChannelToChain".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ChannelToChain".into()
    }
}
/// VscUnbondingOps contains the IDs of unbonding operations that are waiting for
/// at least one VSCMaturedPacket with vscID from a consumer chain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VscUnbondingOps {
    #[prost(uint64, tag = "1")]
    pub vsc_id: u64,
    #[prost(uint64, repeated, tag = "2")]
    pub unbonding_op_ids: ::prost::alloc::vec::Vec<u64>,
}
impl ::prost::Name for VscUnbondingOps {
    const NAME: &'static str = "VscUnbondingOps";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.VscUnbondingOps".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.VscUnbondingOps".into()
    }
}
/// UnbondingOp contains the ids of consumer chains that need to unbond before
/// the unbonding operation with the given ID can unbond
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnbondingOp {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// consumer chains that are still unbonding
    #[prost(string, repeated, tag = "2")]
    pub unbonding_consumer_chains: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for UnbondingOp {
    const NAME: &'static str = "UnbondingOp";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.UnbondingOp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.UnbondingOp".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitTimeoutTimestamp {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
}
impl ::prost::Name for InitTimeoutTimestamp {
    const NAME: &'static str = "InitTimeoutTimestamp";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.InitTimeoutTimestamp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.InitTimeoutTimestamp".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VscSendTimestamp {
    #[prost(uint64, tag = "1")]
    pub vsc_id: u64,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
}
impl ::prost::Name for VscSendTimestamp {
    const NAME: &'static str = "VscSendTimestamp";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.VscSendTimestamp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.VscSendTimestamp".into()
    }
}
/// ValidatorSetChangePackets is a pb list of ccv.ValidatorSetChangePacketData.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSetChangePackets {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<super::super::v1::ValidatorSetChangePacketData>,
}
impl ::prost::Name for ValidatorSetChangePackets {
    const NAME: &'static str = "ValidatorSetChangePackets";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorSetChangePackets".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorSetChangePackets".into()
    }
}
/// MaturedUnbondingOps defines a list of ids corresponding to ids of matured
/// unbonding operations.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaturedUnbondingOps {
    #[prost(uint64, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<u64>,
}
impl ::prost::Name for MaturedUnbondingOps {
    const NAME: &'static str = "MaturedUnbondingOps";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.MaturedUnbondingOps".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.MaturedUnbondingOps".into()
    }
}
/// ExportedVscSendTimestamps is VscSendTimestamp with chainID info for exporting to genesis
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportedVscSendTimestamp {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub vsc_send_timestamps: ::prost::alloc::vec::Vec<VscSendTimestamp>,
}
impl ::prost::Name for ExportedVscSendTimestamp {
    const NAME: &'static str = "ExportedVscSendTimestamp";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ExportedVscSendTimestamp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ExportedVscSendTimestamp".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyAssignmentReplacement {
    #[prost(bytes = "vec", tag = "1")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub prev_c_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
    #[prost(int64, tag = "3")]
    pub power: i64,
}
impl ::prost::Name for KeyAssignmentReplacement {
    const NAME: &'static str = "KeyAssignmentReplacement";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.KeyAssignmentReplacement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.KeyAssignmentReplacement".into()
    }
}
/// Used to serialize the ValidatorConsumerPubKey index from key assignment
/// ValidatorConsumerPubKey: (chainID, providerAddr consAddr) -> consumerKey
/// tmprotocrypto.PublicKey
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorConsumerPubKey {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub consumer_key: ::core::option::Option<::tendermint_proto::crypto::PublicKey>,
}
impl ::prost::Name for ValidatorConsumerPubKey {
    const NAME: &'static str = "ValidatorConsumerPubKey";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorConsumerPubKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorConsumerPubKey".into()
    }
}
/// Used to serialize the ValidatorConsumerAddr index from key assignment
/// ValidatorByConsumerAddr: (chainID, consumerAddr consAddr) -> providerAddr
/// consAddr
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorByConsumerAddr {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub consumer_addr: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub provider_addr: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for ValidatorByConsumerAddr {
    const NAME: &'static str = "ValidatorByConsumerAddr";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValidatorByConsumerAddr".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValidatorByConsumerAddr".into()
    }
}
/// Used to serialize the ConsumerAddrsToPrune index from key assignment
/// ConsumerAddrsToPrune: (chainID, vscID uint64) -> consumerAddrs AddressList
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerAddrsToPrune {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub vsc_id: u64,
    #[prost(message, optional, tag = "3")]
    pub consumer_addrs: ::core::option::Option<AddressList>,
}
impl ::prost::Name for ConsumerAddrsToPrune {
    const NAME: &'static str = "ConsumerAddrsToPrune";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerAddrsToPrune".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerAddrsToPrune".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerGenesisRequest {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryConsumerGenesisRequest {
    const NAME: &'static str = "QueryConsumerGenesisRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerGenesisRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerGenesisRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerGenesisResponse {
    #[prost(message, optional, tag = "1")]
    pub genesis_state: ::core::option::Option<super::super::v1::ConsumerGenesisState>,
}
impl ::prost::Name for QueryConsumerGenesisResponse {
    const NAME: &'static str = "QueryConsumerGenesisResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerGenesisResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerGenesisResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsRequest {}
impl ::prost::Name for QueryConsumerChainsRequest {
    const NAME: &'static str = "QueryConsumerChainsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainsResponse {
    #[prost(message, repeated, tag = "1")]
    pub chains: ::prost::alloc::vec::Vec<Chain>,
}
impl ::prost::Name for QueryConsumerChainsResponse {
    const NAME: &'static str = "QueryConsumerChainsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainStartProposalsRequest {}
impl ::prost::Name for QueryConsumerChainStartProposalsRequest {
    const NAME: &'static str = "QueryConsumerChainStartProposalsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainStartProposalsRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainStartProposalsRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainStartProposalsResponse {
    #[prost(message, optional, tag = "1")]
    pub proposals: ::core::option::Option<ConsumerAdditionProposals>,
}
impl ::prost::Name for QueryConsumerChainStartProposalsResponse {
    const NAME: &'static str = "QueryConsumerChainStartProposalsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainStartProposalsResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainStartProposalsResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainStopProposalsRequest {}
impl ::prost::Name for QueryConsumerChainStopProposalsRequest {
    const NAME: &'static str = "QueryConsumerChainStopProposalsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainStopProposalsRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainStopProposalsRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConsumerChainStopProposalsResponse {
    #[prost(message, optional, tag = "1")]
    pub proposals: ::core::option::Option<ConsumerRemovalProposals>,
}
impl ::prost::Name for QueryConsumerChainStopProposalsResponse {
    const NAME: &'static str = "QueryConsumerChainStopProposalsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryConsumerChainStopProposalsResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryConsumerChainStopProposalsResponse"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chain {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_id: ::prost::alloc::string::String,
}
impl ::prost::Name for Chain {
    const NAME: &'static str = "Chain";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.Chain".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.Chain".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerAddrRequest {
    /// The id of the consumer chain
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// The consensus address of the validator on the provider chain
    #[prost(string, tag = "2")]
    pub provider_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerAddrRequest {
    const NAME: &'static str = "QueryValidatorConsumerAddrRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorConsumerAddrResponse {
    /// The address of the validator on the consumer chain
    #[prost(string, tag = "1")]
    pub consumer_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorConsumerAddrResponse {
    const NAME: &'static str = "QueryValidatorConsumerAddrResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorConsumerAddrResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorProviderAddrRequest {
    /// The id of the provider chain
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// The consensus address of the validator on the consumer chain
    #[prost(string, tag = "2")]
    pub consumer_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorProviderAddrRequest {
    const NAME: &'static str = "QueryValidatorProviderAddrRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorProviderAddrRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorProviderAddrRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryValidatorProviderAddrResponse {
    /// The address of the validator on the provider chain
    #[prost(string, tag = "1")]
    pub provider_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryValidatorProviderAddrResponse {
    const NAME: &'static str = "QueryValidatorProviderAddrResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryValidatorProviderAddrResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryValidatorProviderAddrResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryThrottleStateRequest {}
impl ::prost::Name for QueryThrottleStateRequest {
    const NAME: &'static str = "QueryThrottleStateRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottleStateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottleStateRequest".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryThrottleStateResponse {
    /// current slash_meter state
    #[prost(int64, tag = "1")]
    pub slash_meter: i64,
    /// allowance of voting power units (int) that the slash meter is given per
    /// replenish period this also serves as the max value for the meter.
    #[prost(int64, tag = "2")]
    pub slash_meter_allowance: i64,
    /// next time the slash meter could potentially be replenished, iff it's not
    /// full
    #[prost(message, optional, tag = "3")]
    pub next_replenish_candidate: ::core::option::Option<
        super::super::super::super::google::protobuf::Timestamp,
    >,
    /// data relevant to currently throttled slash packets
    #[prost(message, repeated, tag = "4")]
    pub packets: ::prost::alloc::vec::Vec<ThrottledSlashPacket>,
}
impl ::prost::Name for QueryThrottleStateResponse {
    const NAME: &'static str = "QueryThrottleStateResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottleStateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottleStateResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryThrottledConsumerPacketDataRequest {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryThrottledConsumerPacketDataRequest {
    const NAME: &'static str = "QueryThrottledConsumerPacketDataRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottledConsumerPacketDataRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottledConsumerPacketDataRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryThrottledConsumerPacketDataResponse {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub size: u64,
    #[prost(message, repeated, tag = "3")]
    pub packet_data_instances: ::prost::alloc::vec::Vec<ThrottledPacketDataWrapper>,
}
impl ::prost::Name for QueryThrottledConsumerPacketDataResponse {
    const NAME: &'static str = "QueryThrottledConsumerPacketDataResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryThrottledConsumerPacketDataResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryThrottledConsumerPacketDataResponse"
            .into()
    }
}
/// A query wrapper type for the global entry and data relevant to a throttled
/// slash packet.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThrottledSlashPacket {
    #[prost(message, optional, tag = "1")]
    pub global_entry: ::core::option::Option<GlobalSlashEntry>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<super::super::v1::SlashPacketData>,
}
impl ::prost::Name for ThrottledSlashPacket {
    const NAME: &'static str = "ThrottledSlashPacket";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ThrottledSlashPacket".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ThrottledSlashPacket".into()
    }
}
/// ThrottledPacketDataWrapper contains either SlashPacketData or
/// VSCMaturedPacketData
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThrottledPacketDataWrapper {
    #[prost(oneof = "throttled_packet_data_wrapper::Data", tags = "1, 2")]
    pub data: ::core::option::Option<throttled_packet_data_wrapper::Data>,
}
/// Nested message and enum types in `ThrottledPacketDataWrapper`.
pub mod throttled_packet_data_wrapper {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        SlashPacket(super::super::super::v1::SlashPacketData),
        #[prost(message, tag = "2")]
        VscMaturedPacket(super::super::super::v1::VscMaturedPacketData),
    }
}
impl ::prost::Name for ThrottledPacketDataWrapper {
    const NAME: &'static str = "ThrottledPacketDataWrapper";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ThrottledPacketDataWrapper".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ThrottledPacketDataWrapper".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRegisteredConsumerRewardDenomsRequest {}
impl ::prost::Name for QueryRegisteredConsumerRewardDenomsRequest {
    const NAME: &'static str = "QueryRegisteredConsumerRewardDenomsRequest";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsRequest"
            .into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRegisteredConsumerRewardDenomsResponse {
    #[prost(string, repeated, tag = "1")]
    pub denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryRegisteredConsumerRewardDenomsResponse {
    const NAME: &'static str = "QueryRegisteredConsumerRewardDenomsResponse";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.QueryRegisteredConsumerRewardDenomsResponse"
            .into()
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod query_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ConsumerGenesis queries the genesis state needed to start a consumer chain
        /// whose proposal has been accepted
        pub async fn query_consumer_genesis(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerGenesisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerGenesisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerGenesis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ConsumerChains queries active consumer chains supported by the provider
        /// chain
        pub async fn query_consumer_chains(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryConsumerChainsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChains",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChains",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerChainStarts queries consumer chain start proposals.
        pub async fn query_consumer_chain_starts(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryConsumerChainStartProposalsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainStartProposalsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStarts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChainStarts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryConsumerChainStops queries consumer chain stop proposals.
        pub async fn query_consumer_chain_stops(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryConsumerChainStopProposalsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainStopProposalsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStops",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryConsumerChainStops",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryValidatorConsumerAddr queries the address
        /// assigned by a validator for a consumer chain.
        pub async fn query_validator_consumer_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidatorConsumerAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerAddrResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryValidatorConsumerAddr",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryProviderAddr returns the provider chain validator
        /// given a consumer chain validator address
        pub async fn query_validator_provider_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryValidatorProviderAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorProviderAddrResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryValidatorProviderAddr",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryThrottleState returns the main on-chain state relevant to currently
        /// throttled slash packets
        pub async fn query_throttle_state(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryThrottleStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottleStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryThrottleState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryThrottleState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryThrottledConsumerPacketData returns a list of pending packet data
        /// instances (slash packet and vsc matured) for a single consumer chain
        pub async fn query_throttled_consumer_packet_data(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryThrottledConsumerPacketDataRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottledConsumerPacketDataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryThrottledConsumerPacketData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryThrottledConsumerPacketData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
        /// denoms that are registered
        pub async fn query_registered_consumer_reward_denoms(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryRegisteredConsumerRewardDenomsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryRegisteredConsumerRewardDenomsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "interchain_security.ccv.provider.v1.Query",
                        "QueryRegisteredConsumerRewardDenoms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod query_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServer.
    #[async_trait]
    pub trait Query: Send + Sync + 'static {
        /// ConsumerGenesis queries the genesis state needed to start a consumer chain
        /// whose proposal has been accepted
        async fn query_consumer_genesis(
            &self,
            request: tonic::Request<super::QueryConsumerGenesisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerGenesisResponse>,
            tonic::Status,
        >;
        /// ConsumerChains queries active consumer chains supported by the provider
        /// chain
        async fn query_consumer_chains(
            &self,
            request: tonic::Request<super::QueryConsumerChainsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainsResponse>,
            tonic::Status,
        >;
        /// QueryConsumerChainStarts queries consumer chain start proposals.
        async fn query_consumer_chain_starts(
            &self,
            request: tonic::Request<super::QueryConsumerChainStartProposalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainStartProposalsResponse>,
            tonic::Status,
        >;
        /// QueryConsumerChainStops queries consumer chain stop proposals.
        async fn query_consumer_chain_stops(
            &self,
            request: tonic::Request<super::QueryConsumerChainStopProposalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryConsumerChainStopProposalsResponse>,
            tonic::Status,
        >;
        /// QueryValidatorConsumerAddr queries the address
        /// assigned by a validator for a consumer chain.
        async fn query_validator_consumer_addr(
            &self,
            request: tonic::Request<super::QueryValidatorConsumerAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorConsumerAddrResponse>,
            tonic::Status,
        >;
        /// QueryProviderAddr returns the provider chain validator
        /// given a consumer chain validator address
        async fn query_validator_provider_addr(
            &self,
            request: tonic::Request<super::QueryValidatorProviderAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryValidatorProviderAddrResponse>,
            tonic::Status,
        >;
        /// QueryThrottleState returns the main on-chain state relevant to currently
        /// throttled slash packets
        async fn query_throttle_state(
            &self,
            request: tonic::Request<super::QueryThrottleStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottleStateResponse>,
            tonic::Status,
        >;
        /// QueryThrottledConsumerPacketData returns a list of pending packet data
        /// instances (slash packet and vsc matured) for a single consumer chain
        async fn query_throttled_consumer_packet_data(
            &self,
            request: tonic::Request<super::QueryThrottledConsumerPacketDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryThrottledConsumerPacketDataResponse>,
            tonic::Status,
        >;
        /// QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
        /// denoms that are registered
        async fn query_registered_consumer_reward_denoms(
            &self,
            request: tonic::Request<super::QueryRegisteredConsumerRewardDenomsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryRegisteredConsumerRewardDenomsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct QueryServer<T: Query> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Query> QueryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServer<T>
    where
        T: Query,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerGenesisSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerGenesisRequest>
                    for QueryConsumerGenesisSvc<T> {
                        type Response = super::QueryConsumerGenesisResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryConsumerGenesisRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_genesis(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerGenesisSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChains" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryConsumerChainsRequest>
                    for QueryConsumerChainsSvc<T> {
                        type Response = super::QueryConsumerChainsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryConsumerChainsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chains(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStarts" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainStartsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryConsumerChainStartProposalsRequest,
                    > for QueryConsumerChainStartsSvc<T> {
                        type Response = super::QueryConsumerChainStartProposalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerChainStartProposalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chain_starts(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainStartsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryConsumerChainStops" => {
                    #[allow(non_camel_case_types)]
                    struct QueryConsumerChainStopsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryConsumerChainStopProposalsRequest,
                    > for QueryConsumerChainStopsSvc<T> {
                        type Response = super::QueryConsumerChainStopProposalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryConsumerChainStopProposalsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_consumer_chain_stops(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryConsumerChainStopsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr" => {
                    #[allow(non_camel_case_types)]
                    struct QueryValidatorConsumerAddrSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryValidatorConsumerAddrRequest,
                    > for QueryValidatorConsumerAddrSvc<T> {
                        type Response = super::QueryValidatorConsumerAddrResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryValidatorConsumerAddrRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_validator_consumer_addr(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryValidatorConsumerAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr" => {
                    #[allow(non_camel_case_types)]
                    struct QueryValidatorProviderAddrSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryValidatorProviderAddrRequest,
                    > for QueryValidatorProviderAddrSvc<T> {
                        type Response = super::QueryValidatorProviderAddrResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryValidatorProviderAddrRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_validator_provider_addr(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryValidatorProviderAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryThrottleState" => {
                    #[allow(non_camel_case_types)]
                    struct QueryThrottleStateSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryThrottleStateRequest>
                    for QueryThrottleStateSvc<T> {
                        type Response = super::QueryThrottleStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryThrottleStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_throttle_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryThrottleStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryThrottledConsumerPacketData" => {
                    #[allow(non_camel_case_types)]
                    struct QueryThrottledConsumerPacketDataSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryThrottledConsumerPacketDataRequest,
                    > for QueryThrottledConsumerPacketDataSvc<T> {
                        type Response = super::QueryThrottledConsumerPacketDataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryThrottledConsumerPacketDataRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_throttled_consumer_packet_data(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryThrottledConsumerPacketDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms" => {
                    #[allow(non_camel_case_types)]
                    struct QueryRegisteredConsumerRewardDenomsSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryRegisteredConsumerRewardDenomsRequest,
                    > for QueryRegisteredConsumerRewardDenomsSvc<T> {
                        type Response = super::QueryRegisteredConsumerRewardDenomsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryRegisteredConsumerRewardDenomsRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::query_registered_consumer_reward_denoms(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryRegisteredConsumerRewardDenomsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Query> Clone for QueryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Query> tonic::server::NamedService for QueryServer<T> {
        const NAME: &'static str = "interchain_security.ccv.provider.v1.Query";
    }
}
/// GenesisState defines the CCV provider chain genesis state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// strictly positive and set to 1 (DefaultValsetUpdateID) for a new chain
    #[prost(uint64, tag = "1")]
    pub valset_update_id: u64,
    /// empty for a new chain
    #[prost(message, repeated, tag = "2")]
    pub consumer_states: ::prost::alloc::vec::Vec<ConsumerState>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "3")]
    pub unbonding_ops: ::prost::alloc::vec::Vec<UnbondingOp>,
    /// empty for a new chain
    #[prost(message, optional, tag = "4")]
    pub mature_unbonding_ops: ::core::option::Option<MaturedUnbondingOps>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "5")]
    pub valset_update_id_to_height: ::prost::alloc::vec::Vec<ValsetUpdateIdToHeight>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "6")]
    pub consumer_addition_proposals: ::prost::alloc::vec::Vec<ConsumerAdditionProposal>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "7")]
    pub consumer_removal_proposals: ::prost::alloc::vec::Vec<ConsumerRemovalProposal>,
    #[prost(message, optional, tag = "8")]
    pub params: ::core::option::Option<Params>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "9")]
    pub validator_consumer_pubkeys: ::prost::alloc::vec::Vec<ValidatorConsumerPubKey>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "10")]
    pub validators_by_consumer_addr: ::prost::alloc::vec::Vec<ValidatorByConsumerAddr>,
    /// empty for a new chain
    #[prost(message, repeated, tag = "11")]
    pub consumer_addrs_to_prune: ::prost::alloc::vec::Vec<ConsumerAddrsToPrune>,
    #[prost(message, repeated, tag = "12")]
    pub init_timeout_timestamps: ::prost::alloc::vec::Vec<InitTimeoutTimestamp>,
    #[prost(message, repeated, tag = "13")]
    pub exported_vsc_send_timestamps: ::prost::alloc::vec::Vec<ExportedVscSendTimestamp>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.GenesisState".into()
    }
}
/// The provider CCV module's knowledge of consumer state.
///
/// Note this type is only used internally to the provider CCV module.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumerState {
    /// ChainID defines the chain ID for the consumer chain
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    /// ChannelID defines the IBC channel ID for the consumer chain
    #[prost(string, tag = "2")]
    pub channel_id: ::prost::alloc::string::String,
    /// ClientID defines the IBC client ID for the consumer chain
    #[prost(string, tag = "3")]
    pub client_id: ::prost::alloc::string::String,
    /// InitalHeight defines the initial block height for the consumer chain
    #[prost(uint64, tag = "4")]
    pub initial_height: u64,
    /// ConsumerGenesis defines the initial consumer chain genesis states
    #[prost(message, optional, tag = "5")]
    pub consumer_genesis: ::core::option::Option<super::super::v1::ConsumerGenesisState>,
    /// PendingValsetChanges defines the pending validator set changes for the
    /// consumer chain
    #[prost(message, repeated, tag = "6")]
    pub pending_valset_changes: ::prost::alloc::vec::Vec<
        super::super::v1::ValidatorSetChangePacketData,
    >,
    #[prost(string, repeated, tag = "7")]
    pub slash_downtime_ack: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// UnbondingOpsIndex defines the unbonding operations waiting on this consumer
    /// chain
    #[prost(message, repeated, tag = "8")]
    pub unbonding_ops_index: ::prost::alloc::vec::Vec<VscUnbondingOps>,
}
impl ::prost::Name for ConsumerState {
    const NAME: &'static str = "ConsumerState";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ConsumerState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ConsumerState".into()
    }
}
/// ValsetUpdateIdToHeight defines the genesis information for the mapping
/// of each valset udpate id to a block height
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValsetUpdateIdToHeight {
    #[prost(uint64, tag = "1")]
    pub valset_update_id: u64,
    #[prost(uint64, tag = "2")]
    pub height: u64,
}
impl ::prost::Name for ValsetUpdateIdToHeight {
    const NAME: &'static str = "ValsetUpdateIdToHeight";
    const PACKAGE: &'static str = "interchain_security.ccv.provider.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "interchain_security.ccv.provider.v1.ValsetUpdateIdToHeight".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/interchain_security.ccv.provider.v1.ValsetUpdateIdToHeight".into()
    }
}
